/*	$Id: rsadipir.c,v 1.52 1994/09/20 20:12:03 markn Exp $
**
*	code for RSA and MD5 checking
**
**	3DO Confidential -- Contains 3DO Trade Secrets -- internal use only
*/
#include "types.h"
#include "rsa.h"
#include "global.h"
#include "bsafe2.h"
#include "aif.h"
#include "dipir.h"


#define DOWNCODE_RSA
/* #define DUMP_RSA_DETAILS 1 */


static int ContextRSAFinal(unsigned char *signature,
			   int signatureLen, A_RSA_KEY *key,
			   unsigned char *digest);
static int NewRSAFinal(A_RSA_KEY *key,
		unsigned char *sig, int siglen,
			    unsigned char *digest);

#ifdef DEMO_KEY
/* No-security key for Stan and Bryce */
static unsigned char PUBLIC_DEMOKEY_MOD[] = {
  0x00, 0xc0, 0x76, 0x47, 0x97, 0xb8, 0xbe, 0xc8, 0x97, 0x2a, 0x0e, 0xd8,
  0xc9, 0x0a, 0x8c, 0x33, 0x4d, 0xd0, 0x49, 0xad, 0xd0, 0x22, 0x2c, 0x09,
  0xd2, 0x0b, 0xe0, 0xa7, 0x9e, 0x33, 0x89, 0x10, 0xbc, 0xae, 0x42, 0x20,
  0x60, 0x90, 0x6a, 0xe0, 0x22, 0x1d, 0xe3, 0xf3, 0xfc, 0x74, 0x7c, 0xcf,
  0x98, 0xae, 0xcc, 0x85, 0xd6, 0xed, 0xc5, 0x2d, 0x93, 0xd5, 0xb7, 0x39,
  0x67, 0x76, 0x16, 0x05, 0x25
};
#endif

#ifdef ENG_KEY
#undef WHO_KNOWS
static unsigned char PUBLIC_ENGKEY_MOD[] = {
#ifdef WHO_KNOWS
  0x00, 0xC4, 0x15, 0xCD, 0x46, 0x50, 0x12, 0xE5, 0xA6, 0xBA, 0x07, 0xCC,
  0xD4, 0xA0, 0x0A, 0xCD, 0xC4, 0xFB, 0x82, 0xF6, 0x23, 0x39, 0x39, 0x48,
  0x41, 0x92, 0xEB, 0x3E, 0x99, 0x05, 0x1D, 0x32, 0x72, 0x84, 0x87, 0x1C,
  0x17, 0x21, 0x2F, 0x71, 0x73, 0xD2, 0x7F, 0x9A, 0x7B, 0xB7, 0xD3, 0x22,
  0x06, 0x26, 0x92, 0xB1, 0x81, 0x22, 0x55, 0xF7, 0x2F, 0x9C, 0x85, 0xA5,
  0x17, 0x92, 0xB1, 0x03, 0xE7
#else
  0x00, 0xCC, 0xDD, 0xB7, 0xD6, 0x09, 0x84, 0xA4, 0xA7, 0xFF, 0x68, 0x41,
  0xEA, 0xF1, 0xB4, 0xDF, 0x8E, 0xDD, 0x26, 0xBD, 0x31, 0x5C, 0xA7, 0x26,
  0x81, 0x05, 0x8D, 0xE1, 0x2F, 0x47, 0x7A, 0x5A, 0x5B, 0x84, 0xD4, 0xF2,
  0xE3, 0x2D, 0xD4, 0x8B, 0xDB, 0x8B, 0x4A, 0x04, 0x17, 0x6C, 0x8F, 0x96,
  0xD5, 0xB1, 0x94, 0xC2, 0x70, 0xA3, 0x05, 0x93, 0xA9, 0xEA, 0x40, 0x32,
  0xD0, 0x03, 0x8C, 0xAE, 0x2D
#endif
};
#endif

#undef BILL_TESTKEY	/* Enable low-security key for Bill Duval */
static unsigned char PUBLIC_APPKEY_MOD[] = {
#ifdef BILL_TESTKEY
  0x00, 0xd1, 0xb4, 0xa5, 0x26, 0x40, 0x01, 0xa6, 0xe2, 0x76, 0x49, 0x93,
  0xd2, 0xb9, 0x3f, 0x74, 0x4c, 0xd1, 0x31, 0x7f, 0x03, 0xf2, 0xa1, 0x04,
  0x60, 0x31, 0x46, 0xe6, 0xd7, 0xe0, 0x54, 0x14, 0xfd, 0xc7, 0xa6, 0xd8,
  0x32, 0x87, 0xd3, 0xa2, 0xeb, 0xcd, 0xd8, 0x53, 0xd4, 0x4d, 0x6f, 0x86,
  0x06, 0xf0, 0x45, 0xbd, 0xd7, 0x21, 0x1e, 0xf5, 0xd8, 0x08, 0xd5, 0x5e,
  0xe1, 0xdb, 0x52, 0xb1, 0x33
#else
  0x00, 0xBC, 0x0B, 0x19, 0x90, 0x86, 0xC7, 0xF2, 0x6C, 0xBC, 0x9D, 0x50,
  0xF4, 0x04, 0x94, 0x4D, 0xB4, 0x78, 0x9F, 0xCB, 0xFC, 0xF7, 0xAD, 0x8D,
  0xBC, 0x21, 0x20, 0x89, 0x8A, 0xBE, 0xAA, 0xF3, 0x11, 0xEE, 0xA2, 0x02,
  0x29, 0x03, 0x56, 0x08, 0x84, 0x1F, 0xA4, 0x10, 0x73, 0xAB, 0xBD, 0x5D,
  0x37, 0x50, 0x0C, 0x60, 0xB5, 0x3B, 0xFB, 0x46, 0x60, 0x57, 0x40, 0x38,
  0x1B, 0x72, 0xC9, 0xDB, 0x71
#endif
};

#undef THDO_FAKEKEY
static unsigned char PUBLIC_THDOKEY_MOD[] = {
#ifdef THDO_FAKEKEY
  0x00, 0xcc, 0xdd, 0xb7, 0xd6, 0x09, 0x84, 0xa4, 0xa7, 0xff, 0x68, 0x41,
  0xea, 0xf1, 0xb4, 0xdf, 0x8e, 0xdd, 0x26, 0xbd, 0x31, 0x5c, 0xa7, 0x26,
  0x81, 0x05, 0x8d, 0xe1, 0x2f, 0x47, 0x7a, 0x5a, 0x5b, 0x84, 0xd4, 0xf2,
  0xe3, 0x2d, 0xd4, 0x8b, 0xdb, 0x8b, 0x4a, 0x04, 0x17, 0x6c, 0x8f, 0x96,
  0xd5, 0xb1, 0x94, 0xc2, 0x70, 0xa3, 0x05, 0x93, 0xa9, 0xea, 0x40, 0x32,
  0xd0, 0x03, 0x8c, 0xae, 0x2d
#else
  0x00, 0xB1, 0x94, 0x62, 0xB0, 0x0D, 0x8D, 0x6E, 0x1E, 0xC9, 0x09, 0xAB,
  0x38, 0x5E, 0x06, 0xFE, 0x03, 0x4B, 0xFD, 0x28, 0x2E, 0x9F, 0xFD, 0xC5,
  0x84, 0x83, 0x8C, 0x15, 0xF1, 0x25, 0x93, 0xDD, 0x1E, 0x3A, 0x8B, 0x56,
  0x26, 0xF1, 0xB9, 0xD0, 0xED, 0x0C, 0x38, 0x4E, 0xF6, 0xC5, 0xD1, 0x45,
  0x12, 0xBD, 0x72, 0xDD, 0xB8, 0x5B, 0x44, 0x08, 0x0E, 0x04, 0x72, 0xC0,
  0x3D, 0x0A, 0xFC, 0x4C, 0x97
#endif
};


#define MODULUS_LEN	65	/* See also SIG_LEN */
static unsigned char PUBLIC_KEY_EXP[] = { 1, 0, 1 };

#ifdef DEMO_KEY
static A_RSA_KEY a_demo_key;
#endif

#ifdef ENG_KEY
static A_RSA_KEY a_eng_key;
#endif

static A_RSA_KEY a_app_key;
static A_RSA_KEY a_thdo_key;
uint32 thdoKey = 0;

typedef unsigned int uint;
#define PROTO(x)	x


#ifndef DOWNCODE_RSA
typedef struct {
	int (*Query) PROTO ((unsigned int *, POINTER, POINTER, unsigned int));
	int (*Init)  PROTO ((POINTER, POINTER,POINTER,uint, A_SURRENDER_CTX *));
	int (*Update)PROTO ((POINTER, uchar *, uint *, uint, uchar *, uint,
			A_SURRENDER_CTX *));
	int (*Final) PROTO ((POINTER, uchar *, uint *, uint,
			A_SURRENDER_CTX *));
	int (*GetMaxOutputLen)PROTO ((POINTER, uint *, uint));
	int (*GetBlockLen)PROTO ((POINTER, uint *));
} A_DECRYPT_ALGA;
extern A_DECRYPT_ALGA A_RSA_DECRYPT;
#endif

/*
 * We have two contexts to take care of. Dipir can happen in the
 * middle of the kernels rsa check, so they must be kept separate.
 */
#define DIPIR_CONTEXT	0

/* looks like it is 64 bytes, not 65 bytes */
unsigned int PKCS1[(MODULUS_LEN-16)/sizeof(int)] =	/* !!!!!!!!!!! */
{
	0x0001ffff, 0xffffffff, 0xffffffff, 0xffffffff,
	0xffffffff, 0xffffffff, 0xffffffff, 0xff003020,
	0x300c0608, 0x2a864886, 0xf70d0205, 0x05000410,
};

unsigned int DIGEST[4];

/* helper routines */

/* 0x200 empirically defined by looking at Query result */
/* one context for dipir one for kernel */

MD5_CTX	digest_context;

static unsigned char PUBLIC_SIGNATURES_ARRAY[] = {
 0x0a, 0x54, 0x68, 0x69, 0x73, 0x20, 0x57, 0x48, 0x4f, 0x4c, 0x4c, 0x59, 
 0x20, 0x4f, 0x44, 0x44, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 
 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x20, 
 0x62, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x79, 
 0x6f, 0x75, 0x20, 0x62, 0x79, 0x3a, 0x0a, 0x0a, 0x44, 0x61, 0x6c, 0x65, 
 0x20, 0x22, 0x59, 0x6f, 0x75, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x20, 0x6d, 
 0x79, 0x20, 0x68, 0x6f, 0x75, 0x73, 0x65, 0x20, 0x62, 0x75, 0x72, 0x6e, 
 0x65, 0x64, 0x20, 0x64, 0x6f, 0x77, 0x6e, 0x20, 0x6c, 0x61, 0x73, 0x74, 
 0x20, 0x6d, 0x6f, 0x6e, 0x74, 0x68, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x49, 
 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x69, 0x63, 
 0x65, 0x64, 0x3f, 0x22, 0x20, 0x4c, 0x75, 0x63, 0x6b, 0x0a, 0x2d, 0x3d, 
 0x52, 0x4a, 0x3d, 0x2d, 0x20, 0x22, 0x48, 0x65, 0x79, 0x2c, 0x20, 0x49, 
 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x61, 0x70, 0x70, 0x72, 0x6f, 
 0x76, 0x65, 0x64, 0x20, 0x74, 0x68, 0x6f, 0x73, 0x65, 0x20, 0x6d, 0x65, 
 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x21, 0x22, 0x20, 0x4d, 0x69, 0x63, 
 0x61, 0x6c, 0x0a, 0x4a, 0x6f, 0x65, 0x20, 0x22, 0x59, 0x6f, 0x75, 0x20, 
 0x77, 0x65, 0x72, 0x65, 0x20, 0x61, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 
 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x22, 
 0x20, 0x50, 0x69, 0x6c, 0x6c, 0x6f, 0x77, 0x0a, 0x44, 0x61, 0x76, 0x65, 
 0x20, 0x22, 0x53, 0x74, 0x72, 0x69, 0x63, 0x74, 0x6c, 0x79, 0x20, 0x63, 
 0x6f, 0x72, 0x65, 0x63, 0x74, 0x22, 0x20, 0x50, 0x6c, 0x61, 0x74, 0x74, 
 0x0a, 0x42, 0x72, 0x79, 0x63, 0x65, 0x20, 0x22, 0x41, 0x6e, 0x67, 0x65, 
 0x6c, 0x20, 0x6f, 0x66, 0x20, 0x64, 0x65, 0x61, 0x74, 0x68, 0x22, 0x20, 
 0x22, 0x4e, 0x65, 0x73, 0x62, 0x69, 0x74, 0x6c, 0x22, 0x20, 0x4e, 0x65, 
 0x73, 0x62, 0x69, 0x74, 0x74, 0x0a, 0x53, 0x74, 0x65, 0x70, 0x68, 0x65, 
 0x6e, 0x20, 0x22, 0x4e, 0x6f, 0x74, 0x20, 0x53, 0x74, 0x65, 0x70, 0x68, 
 0x61, 0x6e, 0x22, 0x20, 0x4c, 0x61, 0x6e, 0x64, 0x72, 0x75, 0x6d, 0x0a, 
 0x41, 0x6e, 0x64, 0x79, 0x20, 0x22, 0x49, 0x20, 0x6d, 0x69, 0x73, 0x73, 
 0x20, 0x6d, 0x79, 0x20, 0x43, 0x61, 0x74, 0x73, 0x22, 0x20, 0x46, 0x69, 
 0x6e, 0x6b, 0x65, 0x6c, 0x0a, 0x43, 0x68, 0x72, 0x69, 0x73, 0x20, 0x22, 
 0x57, 0x68, 0x61, 0x64, 0x64, 0x79, 0x61, 0x20, 0x6d, 0x65, 0x61, 0x6e, 
 0x20, 0x79, 0x6f, 0x75, 0x20, 0x74, 0x6f, 0x6f, 0x6b, 0x20, 0x69, 0x74, 
 0x20, 0x6f, 0x75, 0x74, 0x3f, 0x22, 0x20, 0x4d, 0x63, 0x46, 0x61, 0x6c, 
 0x6c, 0x0a, 0x44, 0x72, 0x65, 0x77, 0x20, 0x22, 0x44, 0x6f, 0x6e, 0x27, 
 0x74, 0x20, 0x74, 0x6f, 0x75, 0x63, 0x68, 0x20, 0x6d, 0x79, 0x20, 0x74, 
 0x6f, 0x79, 0x73, 0x22, 0x20, 0x53, 0x68, 0x65, 0x6c, 0x6c, 0x0a, 0x4d, 
 0x72, 0x2e, 0x20, 0x50, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x0a, 0x4e, 
 0x65, 0x72, 0x66, 0x28, 0x74, 0x6d, 0x29, 0x20, 0x62, 0x72, 0x61, 0x6e, 
 0x64, 0x20, 0x77, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x73, 0x0a, 0x50, 0x68, 
 0x69, 0x6c, 0x20, 0x22, 0x49, 0x20, 0x63, 0x61, 0x6e, 0x27, 0x74, 0x20, 
 0x68, 0x65, 0x61, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x22, 0x20, 0x42, 0x75, 
 0x72, 0x6b, 0x0a, 0x53, 0x74, 0x61, 0x6e, 0x20, 0x22, 0x49, 0x20, 0x74, 
 0x68, 0x6f, 0x75, 0x67, 0x68, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x77, 
 0x65, 0x72, 0x65, 0x20, 0x64, 0x6f, 0x6e, 0x65, 0x22, 0x20, 0x53, 0x68, 
 0x65, 0x70, 0x61, 0x72, 0x64, 0x0a, 0x53, 0x74, 0x65, 0x76, 0x65, 0x20, 
 0x22, 0x54, 0x68, 0x61, 0x74, 0x20, 0x21, 0x40, 0x25, 0x24, 0x23, 0x26, 
 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x22, 0x20, 0x48, 0x61, 0x79, 0x65, 
 0x73, 0x0a, 0x42, 0x69, 0x6c, 0x6c, 0x20, 0x4c, 0x6f, 0x6e, 0x67, 0x0a, 
 0x42, 0x61, 0x72, 0x72, 0x79, 0x20, 0x53, 0x6f, 0x6c, 0x6f, 0x6d, 0x6f, 
 0x6e, 0x0a, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 
 0x68, 0x6f, 0x73, 0x65, 0x20, 0x77, 0x68, 0x6f, 0x20, 0x77, 0x65, 0x72, 
 0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 
 0x20, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x74, 
 0x20, 0x32, 0x61, 0x6d, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 
 0x65, 0x20, 0x63, 0x6f, 0x70, 0x73, 0x0a, 0x73, 0x68, 0x6f, 0x77, 0x65, 
 0x64, 0x20, 0x75, 0x70, 0x2e, 0x2e, 0x2e, 0x0a
};

extern void *malloc(uint);
extern int aRSA(unsigned char *, unsigned char *, unsigned char *, int);

static int NewRSAFinal(A_RSA_KEY *key,
		unsigned char *signature,int signatureLen, unsigned char *d)
{
    int ret;
    unsigned int partOut[MODULUS_LEN/sizeof(int)];
#ifdef DOWNCODE_RSA
    int32 *mod_point;
    uint8 *exp_point;
#else
    uint partOutLen;
    unsigned long rsa_ctx[0x200/sizeof(long)];	
#endif

#ifdef DUMP_RSA_DETAILS
    puts("RSAFinal[");
    puthex((int)signature);puts(",");puthex(signatureLen);
    puts("]");
#endif
    /*FinalDigest();*/

    if (d == 0) d = (unsigned char *)DIGEST;

    if ( (signatureLen < 64) || (signatureLen > 256) )
    {
	puts("Bogus sig len");
	return 0;
    }
#ifdef undef	/* See above.  0x200 from query assumed */
    ret = (*A_RSA_DECRYPT.Query)(&contextsize, (POINTER)&a_rsa_key, 0, 0);
    puts("status from A_RSA.Query="); puthex(status);
    puts(" contextsize="); puthex(contextsize);

    rsacontext = (POINTER)malloc(contextsize);
#endif



#ifndef DOWNCODE_RSA
    ret = (*A_RSA_DECRYPT.Init)((POINTER)rsa_ctx, (POINTER)key, 0, 0, 0);
    ret = (*A_RSA_DECRYPT.Update)((POINTER)rsa_ctx,
    		(uchar *)partOut, &partOutLen, MODULUS_LEN,
    		(uchar *)signature, signatureLen, 0);
    puts(" partOut="); puthex((int)partOut);
#else
  {
    int exp = 0;
    int i;
    mod_point = (int32 *)((POINTER)key->modulus.data);
    exp_point = (uint8 *)((POINTER)key->exponent.data);

    for (i = 0; i < key->exponent.len ; i++ )
    {
	exp <<= 8;
	exp += *exp_point++;
    }

    ret = aRSA( (unsigned char *)partOut,(unsigned char *)signature,
	       (unsigned char *)mod_point,exp);
#ifdef DUMP_RSA_DETAILS
    puts("RSA ret is");puthex(ret);
    puts("RSA exp is"); puthex((int)*exp_point);
    puts("RSA mod is");puthex((int)*mod_point);
    puts(" partOut="); puthex((int)partOut[0]);
#endif
  }
#endif


    /* first compare the constant 48 byte part */
    ret = B_memcmp((char *)partOut,(char *)PKCS1,sizeof(PKCS1));
    if (ret == 0)
    {	/* passed first check */
    	/* now compare the 16 byte digest */
#ifdef DUMP_RSA_DETAILS
        puts("AUTH");
#endif
       	ret = B_memcmp((char *)&partOut[12],(char *)d,sizeof(DIGEST));
	if (ret == 0)
	{
#ifdef DUMP_RSA_DETAILS
        	puts("ENTIC!");
#endif
        	return 1;
	}
    }

#ifdef DUMP_RSA_DETAILS
    puts("BOGUS!");
    puthex((char *)partOut[1]);
    puthex((char *)partOut[2]);
    puthex((char *)partOut[3]);
    puthex((int)partOut[4]);
    puthex((int)partOut[5]);
    puthex((int)partOut[6]);
    puthex((int)partOut[7]);
    puthex((int)partOut[8]);
    puthex((int)partOut[9]);
    puthex((int)partOut[10]);
    puthex((int)partOut[11]);

    {
    int *my_d;
    my_d = (int *)d; 
    puts("d=");
    puthex((int)my_d[0]);
    puthex((int)my_d[1]);
    puthex((int)my_d[2]);
    puthex((int)my_d[3]);

    puts("digest=");
    puthex((int)partOut[12]);
    puthex((int)partOut[13]);
    puthex((int)partOut[14]);
    puthex((int)partOut[15]);
  }
#endif
    return 0;
}



/*
 * Test the specified key and, if this is an unencrypted dipir, the demo key.
 */
static int
ContextRSAFinal( unsigned char *signature,
		int signatureLen, A_RSA_KEY *primary_key, unsigned char *d)
{
	int ok;

#ifdef	DEMO_KEY
        ok = NewRSAFinal(&a_demo_key, signature, signatureLen, d);
	if (ok)
		return 1;
#endif

#ifdef	ENG_KEY
        ok = NewRSAFinal(&a_eng_key, signature, signatureLen, d);
	if (ok)
		return 1;
#endif

	ok = NewRSAFinal(primary_key, signature, signatureLen, d);
	return ok;
}

int
RSAFinalTHDO(unsigned char *signature,int signatureLen)
{
	/* used by dipir code only */
	return ContextRSAFinal(signature, signatureLen, &a_thdo_key, 0);
}

int
RSAFinalAPP(unsigned char *signature,int signatureLen)
{
	/* used by dipir code only */
	return ContextRSAFinal(signature, signatureLen, &a_app_key, 0);
}

int
RSAFinalWithKey(A_RSA_KEY *key, 
		unsigned char *signature,int signatureLen)
{
	/* used by dipir code only */
	return NewRSAFinal(key, signature, signatureLen, 0);
}


/*	Custom 3DO fast decryption scheme	*/
#define MASK1           0xf0f0f0f0L
#define MASK2           0x0f0f0f0fL
#ifdef undef
/* why is this here? */
/*	scratch must point a buffer of at least SIG_LEN bytes */
void
DecryptBlockRSA(uchar *buffer, unsigned long inputlen, uchar *scratch)
{
    unsigned long rsa_ctx[0x200/sizeof(long)];	
    uint PartOutLen = 0;
    char c;
    int ret;

	for( ret=0; ret<=256; ret++ )
		scratch[ret]=0x55;

    puts("buff/len="); puthex(buffer); puthex(inputlen);
    c = buffer[SIG_LEN-1];
    buffer[SIG_LEN-1] = buffer[inputlen - SIG_LEN -4];
    puthex( buffer[SIG_LEN-1] );

    ret = (*A_RSA_DECRYPT.Init)((POINTER)rsa_ctx,
    			(POINTER)PUBLIC_THDOKEY_MOD, 0, 0, 0);
    puts("ret="); puthex((int)ret);
    ret = (*A_RSA_DECRYPT.Update)((POINTER)rsa_ctx,
    		(uchar *)scratch, &PartOutLen, MODULUS_LEN,
    		(uchar *)buffer, (uint)SIG_LEN, NULL);
    puts("ret="); puthex((int)ret);
    puts("Output/Len="); puthex(scratch); puthex(PartOutLen);
    T_memmove((POINTER)buffer, (POINTER)scratch+1, SIG_LEN-1);

    buffer[SIG_LEN-1] =c;
}
#endif

void
DecryptBlock(void *buffer, unsigned long inputlen) 
{
    unsigned long *p, *q;
    unsigned long parta, partb, mask1, mask2;
    int i;

    q = (unsigned long *)&PUBLIC_SIGNATURES_ARRAY;
    mask1 = MASK1;
    mask2 = MASK2;

    p = (unsigned long *)buffer;
    for (i = 0; i <= inputlen / 4; i++)
    {
        if (i % (SIG_LEN / 4) == 0)
            q = (unsigned long *)PUBLIC_THDOKEY_MOD;
        parta = ((*p ^ *q) & mask1) >> 4;
        partb = ((*p ^ *q) & mask2) << 4;
        *p++ = (parta | partb);
        q++;
    }
}


int
RSAInit(void)
{
    /* puts("RSAInit thdoKey="); puthex(thdoKey); */
    if (thdoKey)
	return 0;	/* already initialized */

#ifdef	DEMO_KEY
    a_demo_key.modulus.len = MODULUS_LEN;
    a_demo_key.modulus.data = PUBLIC_DEMOKEY_MOD;
    a_demo_key.exponent.len = 0x3;
    a_demo_key.exponent.data = (POINTER)PUBLIC_KEY_EXP;
#endif

#ifdef	ENG_KEY
    a_eng_key.modulus.len = MODULUS_LEN;
    a_eng_key.modulus.data = PUBLIC_ENGKEY_MOD;
    a_eng_key.exponent.len = 0x3;
    a_eng_key.exponent.data = (POINTER)PUBLIC_KEY_EXP;
#endif

    a_app_key.modulus.len = MODULUS_LEN;
    a_app_key.modulus.data = PUBLIC_APPKEY_MOD;
    a_app_key.exponent.len = 0x3;
    a_app_key.exponent.data = (POINTER)PUBLIC_KEY_EXP;

    a_thdo_key.modulus.len = MODULUS_LEN;
    a_thdo_key.modulus.data = PUBLIC_THDOKEY_MOD;
    a_thdo_key.exponent.len = 0x3;
    a_thdo_key.exponent.data = (POINTER)PUBLIC_KEY_EXP;
    thdoKey = 1; /* Keys have been initialized */

    return 0;
}

int stoprightnow;

int32
GenRSACheck(input,inputLen,signature,signatureLen)
unsigned char *input;
unsigned char *signature;
int inputLen,signatureLen;
{
	int status = 0;
	MD5_CTX md5;
	unsigned char digest[16];

#ifdef DUMP_RSA_DETAILS
	puts("GenRSACheck(in="); puthex(input); puts(","); puthex(inputLen);
	puts("sig="); puthex(signature); puts(",");
					puthex(signatureLen); puts(") ");
#endif

	stoprightnow = 0;

	InitDigest(&md5);
	UpdateDigest(&md5, input, inputLen);
	FinalDigest(&md5, digest);

	stoprightnow = 0;
	
	/*
	 * PRIV	3DO - Check & start prived
	 * ---- 3D0 - Check & start normal
	 * PRIV APP - Nice try, sucker. Check in operator/shell!
	 * ---- APP - Check & start normal
	 */

	status = ContextRSAFinal(signature, signatureLen, &a_thdo_key, digest);
	if (status)
	{
#ifdef DUMP_RSA_DETAILS
		puts("signed with 3DO key");
#endif
		return 1;
	}
	status = ContextRSAFinal(signature, signatureLen, &a_app_key, digest);
	if (status)
	{
#ifdef DUMP_RSA_DETAILS
		puts("signed with app key");
#endif
		return 2;
	}

	puts("data/signature bad");
	return 0;
}

bool
RSACheck(buff,buffsize)
void *buff;
int32 buffsize;
{
	unsigned char *input;
	unsigned char *signature;
	int signatureLen;
	int inputLen;
	AIFHeader *aifp;
	_3DOBinHeader *p;
	unsigned char *q;
	int status = 0;
	unsigned char digest[16];
	MD5_CTX md5;


#ifdef DUMP_RSA_DETAILS
	puts("RSACheck buf="); puthex(buff); puts("size="); puthex(buffsize);
#endif

	status = RSAInit();
	if (status != 0)
	{
	     puts("bad RSAInit!="); puthex(status);
	     return 0;
	}

	aifp = (AIFHeader *)buff;
	if ( 0 == (aifp->aif_WorkSpace & AIF_3DOHEADER) )
		return 0;
	
	p = (_3DOBinHeader *)(aifp + 1);
	q = (unsigned char *)aifp;
	signatureLen = (int)p->_3DO_SignatureLen;
	inputLen = (int)p->_3DO_Signature;
	signature = q + inputLen;	/* offset from beginning */
	p->_3DO_SignatureLen = 0;
	input = q;

#ifdef DUMP_RSA_DETAILS
	puts("sig/len=");	puthex(signature);	puthex(signatureLen);
	puts("input/len=");	puthex(input);		puthex(inputLen);
	puts("flags=");		puthex(p->_3DO_Flags);
#endif

	InitDigest(&md5);
	UpdateDigest(&md5, input, inputLen);
	FinalDigest(&md5, digest);
	
	/*
	 * PRIV	3DO - Check & start prived
	 * ---- 3D0 - Check & start normal
	 * PRIV APP - Nice try, sucker. Check in operator/shell!
	 * ---- APP - Check & start normal
	 */

	if ( p->_3DO_Flags & _3DO_USERAPP ) {
#ifdef DUMP_RSA_DETAILS
		puts("Task needs APP key...");
#endif
		status = ContextRSAFinal(signature,
					 signatureLen, &a_app_key, digest);
	} else {
#ifdef DUMP_RSA_DETAILS
		puts("Task needs 3DO key...");
#endif
		status = ContextRSAFinal(signature,
					 signatureLen, &a_thdo_key, digest);
	}

	if (!status) { puts("Task RSA failed, status="); puthex(status); }
	return status;
}

