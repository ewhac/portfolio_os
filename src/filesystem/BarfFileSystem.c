/*****

$Id: BarfFileSystem.c,v 1.10 1994/09/14 21:15:10 shawn Exp $

$Log: BarfFileSystem.c,v $
 * Revision 1.10  1994/09/14  21:15:10  shawn
 * FS_DIRSEMA should only be defined in filesystem.h.
 *
 * Revision 1.9  1994/09/09  22:00:28  cramer
 * A number of changes:
 * * add multijab logic, which allows the readcallback routine to defer
 *   jabbing the file daemon (in order to schedule BARF IO) if it looks like
 *   we're going to get another reply packet in a little while; this saves
 *   unnecessary context switches.
 * * crank up the number of readers and requestors so we have more cmd writes
 *   and reply reads pending to avoid dropping packets on the floor.
 * * add (for debug purposes) a facility to stop requests after we see our
 *   first timeout.
 * * add & reorganize function prototypes.
 * * make adaptive timeout code the default (no longer #ifdef'ed).
 * * fix bug with reading off of the end of the file.
 * * call InitDirSema (directory semaphore) code when mounting.
 * * if BARFFS not defined, give compiler something to chew on.
 * * misc beautification.
 *
 * Revision 1.8  1994/08/08  17:41:05  cramer
 * Change default multiread block limit to 16.
 * When estimating timeouts, ignore times generated by retried commands.
 * Handle case correctly where blocks arrive while processing
 * timed-out commands.
 * Make timeouts back off exponentially.
 *
 * Revision 1.7  1994/07/25  20:47:55  cramer
 * Add smart retry, adaptive timeout logic,
 * code clean-up and preliminary command profiling.
 *
 * Revision 1.6  1994/07/19  20:57:10  cramer
 * Add code to allow tuning of fs parameters from
 * debugger for testing purposes.
 *
 * Revision 1.5  1994/06/10  23:27:05  cramer
 * remove debug bogosity.
 *
 * Revision 1.4  1994/06/10  23:23:24  cramer
 * fix eof problem, fix panic if run out of requests in file daemon,
 * add comments.
 *
 * Revision 1.3  1994/03/25  21:51:52  dplatt
 * Bring up to date... various & sundry fixes
 *
 * Revision 1.2  1994/01/21  00:29:21  dplatt
 * Recover from RCS bobble
 *
 * Revision 1.1  1993/12/16  00:44:00  dplatt
 * Initial revision
 *

 *****/

/*
  Copyright The 3DO Company, Inc.
  All Rights Reserved Worldwide.
  Company confidential and proprietary.
  Contains unpublished technical data.
*/

/*
  BarfFileSystem.c - support code for BARF network file system
*/


#ifdef BARFFS

#define BARF_VERSION_STRING	"0.2"

/*
   TBD - set the send-buffer sizes so that only the necessary amount
   of request data is written 'cross the wire.
*/

/*
 * These need to be defined before we include any files.
 */
#define SUPER
#define	DO_SMART_RETRY			/* retry timed-out cmds cleverly */
#define DO_REQ_STATS			/* record timestamps in requests */

#undef 	TRACE_REPLIES			/* debug: log replies in trace buf */
#undef 	STOP_AFTER_TIMEOUT		/* stop after 1st timeout */
#define MULTIJAB		/* only jab fs scheduler for mult. pkts */
#undef	MULTIJAB_VERBOSE	/* blab about how multijab works */

#include "types.h"
#include "item.h"
#include "mem.h"
#include "nodes.h"
#include "debug.h"
#include "list.h"
#include "device.h"
#include "driver.h"
#include "kernel.h"
#include "kernelnodes.h"
#include "io.h"
#include "filesystem.h"
#include "filesystemdefs.h"
#include "discdata.h"
#include "directory.h"
#include "operror.h"
#include "barf.h"
#include "barfexport.h"

#include "super.h"

#include "strings.h"

#undef PROFILE_DISK_REQUEST		/* profile disk request times */
#define ADAPTIVE_TIME_OUT		/* predict correct timeout values */
#define DO_ASSERT			/* enable error-checking assertions */

#define BARF_SLIDING_WINDOW
#define SLOW_TIMEOUT
#undef  ZAP_REPLY_BUFFER
#undef  ENDACTION_PROCESS
#undef  ADD_READERS
#define SCAN_FOR_LOST_READERS
#define REPORT_WHEN_IDLE

/* Note: MULTIREAD_BLOCK_LIMIT must be <= 255 */
#ifdef BARF_SLIDING_WINDOW
# define MULTIREAD_BLOCK_LIMIT      16
# define MULTIREAD_WINDOW_SIZE      1
#else
# define MULTIREAD_BLOCK_LIMIT      1
# define MULTIREAD_WINDOW_SIZE      1
#endif

#define BARF_MIN_READERS            32
#define BARF_MIN_REQUESTORS         8

/*
 * Explanation of various timeout constants:
 *
 * BARF_WRITE_TIMEOUT		time from when we logically submit a 
 *				server request to the time the request
 *				goes out on the wire.  This time should
 *				not be operation-type dependent.
 * BARF_INITIAL_TIMEOUT		for all commands other than RF_START &
 *				RF_END, time from time commands goes
 *				out on wire to time we see a response
 *				from the server.
 * BARF_LONG_TIMEOUT		same as BARF_INITIAL_TIMEOUT, for
 *				commands RF_START & RF_END.
 * BARF_INCREMENTAL_TIMEOUT	for all commands, time from period we
 *				get reply to the time we finish processing
 *				the reply (not clear why we need this;
 *				is currently commented out).
 */
#ifdef SLOW_TIMEOUT
# define BARF_WRITE_TIMEOUT        600
# define BARF_INITIAL_TIMEOUT      600
# define BARF_INCREMENTAL_TIMEOUT  600
# define BARF_LONG_TIMEOUT         600
#else
# define BARF_WRITE_TIMEOUT        60
# define BARF_INITIAL_TIMEOUT      60
# define BARF_INCREMENTAL_TIMEOUT  30
# define BARF_LONG_TIMEOUT         300
#endif

#undef DEBUG
#undef DEBUG
#define DEBUG 1
#undef  DEBUG
#undef DEBUG2

#ifdef DEBUG
#define DBUG(x) Superkprintf x
#else
#define DBUG(x) /* x */
#endif

#ifdef DEBUG2
#define DBUG2(x) Superkprintf x
#else
#define DBUG2(x) /* x */
#endif

#ifdef PRODUCTION
# define qprintf(x) /* x */
# define DBUG0(x) /* x */
#else
# define qprintf(x) if (!(KernelBase->kb_CPUFlags & KB_NODBGR)) Superkprintf x
# define DBUG0(x) if (!(KernelBase->kb_CPUFlags & KB_NODBGR)) Superkprintf x
#endif

#if defined(MULTIJAB) && defined(MULTIJAB_VERBOSE)
#define	MULTIJAB_BLAB(x)	Superkprintf x
#else 	/* MULTIJAB */
#define	MULTIJAB_BLAB(x)	/* x */
#endif 	/* MULTIJAB */

/*
 * Useful macros.
 */

/* assert that a condition is true */
#ifdef DO_ASSERT
#define ASSERT(cond) \
	{ if (!(cond)) \
	    qprintf(("ASSERTION FAILED: file \"%s\", line %d\n",\
		   __FILE__, __LINE__)); }
#else
#define ASSERT(cond)
#endif /* DO_ASSERT */

#define MIN(a,b) ((((a)<(b))?(a):(b)))

#define	BLOCKS_TO_BYTES(blocks, file) \
	((blocks) * (file)->fi_BlockSize)

#define BYTES_TO_BLOCKS(bytes, file) \
	/* XXX assumes bytes is an integral multiple of blocksize */ \
	((bytes) / (file)->fi_BlockSize)

#define	BYTES_TO_BLKNUM(bytes, file) \
	((bytes) / (file)->fi_BlockSize)

/* is the window of valid sequence numbers on the server full? */
#define SERVER_WINDOW_FULL(disk) \
	((disk)->bd_NextSequenceNumber - (disk)->bd_OldestSequenceNumber >= \
	 (disk)->bd_ServerWindowSize)

/*
 * Bit array operation macros and
 * assertion-checking variants.
 * All these macros assume that the size of
 * the bit array elements is 32 bits.
 */
#ifndef DO_ASSERT
#define BIT_IS_SET(pageBits, bitNum) \
	(pageBits[((bitNum) >> 5)] & \
	 (((uint32)0x80000000) >> ((bitNum) & 0x1F)))

#define SET_BIT(pageBits, bitNum) \
	(pageBits[((bitNum) >> 5)] |= \
	 (((uint32)0x80000000) >> ((bitNum) & 0x1F)))

#define CLEAR_BIT(pageBits, bitNum) \
	(pageBits[((bitNum) >> 5)] &= \
	 ~(((uint32)0x80000000) >> ((bitNum) & 0x1F)))

#else /* DO_ASSERT */

/* macro wrappers */
#define BIT_IS_SET(pageBits, bitNum) 	bit_is_set_assert(pageBits, bitNum)
#define SET_BIT(pageBits, bitNum) 	set_bit_assert(pageBits, bitNum)
#define CLEAR_BIT(pageBits, bitNum) 	clear_bit_assert(pageBits, bitNum)

/* error checking routines called by wrappers */
static uint32 bit_is_set_assert(uint32 *pageBits, uint32 bitNum)
{
  ASSERT(bitNum < (8 * 32));
  
  return ((pageBits[((bitNum) >> 5)] &
	   (((uint32)0x80000000) >> ((bitNum) & 0x1F))));
}

static void set_bit_assert(uint32 *pageBits, uint32 bitNum)
{
  ASSERT(bitNum < (8 * 32));
  
  pageBits[((bitNum) >> 5)] |= 
	 (((uint32)0x80000000) >> ((bitNum) & 0x1F));
}

static void clear_bit_assert(uint32 *pageBits, uint32 bitNum)
{
  ASSERT(bitNum < (8 * 32));
  
  pageBits[((bitNum) >> 5)] &= 
	 ~(((uint32)0x80000000) >> ((bitNum) & 0x1F));
}
#endif /* DO_ASSERT */

/*
 * BARF request & reply operation codes.
 */
#define BARF_OP(BarfReqOrReply) \
	((BarfReqOrReply).br_OperationType & BARF_OPERATION_MASK)

#define BARF_REPL_OP(repl) \
	(BARF_OP(repl->reply_Barf))

#define BARF_REQ_OP(req) \
	(BARF_OP(req->req_Barf))

#ifdef PROFILE_DISK_REQUEST
/* disk request statistics record */
typedef struct diskReqStat {
	void 		*ioReq;		/* address of our IO request */
	struct timeval	start;		/* start time */
} diskReqStat_t;

#define N_DISK_REQ_STATS	16
diskReqStat_t diskReqStats[N_DISK_REQ_STATS];

uint32 		diskReqTotalBlocks;
struct timeval 	diskReqTotalTime;
uint32 		numstats;
#endif /* PROFILE_DISK_REQUEST */

#ifdef TRACE_REPLIES
uchar reply_trace_buf[16*512];
uint32 rtbi;
#endif

#ifdef ADAPTIVE_TIME_OUT
typedef	struct {
  uint32	timeOut;
  static uint32 scaledAvg;	/* scaled avg. time; "sa" in J & K */
  static uint32 scaledVariance;	/* scaled variance; "sv" in J & K */
} timeOutInfo_t;

/*
 * Information used for calculating timeout values for
 * RF_START .. RF_GET_FILE_SIZE.
 * Note that we do *not* record timeout values for RF_END.
 * We probably don't need to have an entry for each operation,
 * but we'll start out with a very general solution.
 * XXX take care not to run off the end of this array!
 */
timeOutInfo_t timeOutInfo[] =
{
  {BARF_INITIAL_TIMEOUT, 0, 0},		/* RF_START */
  {BARF_INITIAL_TIMEOUT, 0, 0},		/* RF_DIRECTORY_OPEN */
  {BARF_INITIAL_TIMEOUT, 0, 0},		/* RF_DIRECTORY_CLOSE */
  {BARF_INITIAL_TIMEOUT, 0, 0},		/* RF_DIRECTORY_READ */
  {BARF_INITIAL_TIMEOUT, 0, 0},		/* RF_FILE_OPEN */
  {BARF_INITIAL_TIMEOUT, 0, 0},		/* RF_FILE_CLOSE */
  {BARF_INITIAL_TIMEOUT, 0, 0},		/* RF_FILE_READ */
  {BARF_INITIAL_TIMEOUT, 0, 0},		/* RF_MULTI_READ */
  {BARF_INITIAL_TIMEOUT, 0, 0}		/* RF_GET_FILE_SIZE */
};

#define ADAPTIVE_FIXED_TIMEOUT 0	/* ticks to add to calc'd timeout */
#endif

/*
 * Crocky way to set fs parameters: array of values
 * to be filled in by debugger.  If array value is zero,
 * use default value.
 * Crude, but effective.  For debugging use only.
 */
uint32 fsParams[4];
#define	FSPARAM_MULTIREAD_BLOCK_LIMIT	fsParams[0]
#define	FSPARAM_MULTIREAD_WINDOW_SIZE	fsParams[1]
#define	FSPARAM_SIMULATE_WRT_TIMEOUT	(fsParams[2] & 0x1)
#define	FSPARAM_WRT_BASH		(fsParams[2] & 0x2)

#ifdef BARF_SLIDING_WINDOW
# undef MULTIREAD_BLOCK_LIMIT
# define MULTIREAD_BLOCK_LIMIT \
	(fsParams[0] ? fsParams[0]: 16)
# undef MULTIREAD_WINDOW_SIZE
# define MULTIREAD_WINDOW_SIZE \
	(fsParams[1] ? fsParams[1]: 1)
#endif

int32 busyTimer;

#ifdef STOP_AFTER_TIMEOUT
int stop_after_timeout_flag;	/* for debug, stop after 1st timeout */
#endif /* STOP_AFTER_TIMEOUT */

/*
 * Interfaces we import.
 */
extern int32 CloseOpenFile(OpenFile *theOpenFile);
extern Node *AllocFileNode(int32 theSize, int32 theType);
extern void FreeFileNode (void *it);
extern void GiveDaemon(void *foo);
IoCacheEntry *FindCache(OpenFile *theOpenFile, int32 blockNum);
IoCacheEntry *AddCacheEntry(OpenFile *theOpenFile, int32 blockNum,
			    void *buffer,
			    uint8 priority, uint32 format, uint32 bytes);
void AgeCache(void);

/*
 * Interfaces we export.
 */
int32 QueueBarfDiskRequest(BarfDisk *theDevice, IOReq *theRequest);
void ScheduleBarfDiskIo(BarfDisk *theDevice);
void StartBarfDiskIo(BarfDisk *theDevice);
void AbortBarfDiskIo(IOReq *theRequest);
Item MountBarfFilesystem(Device *theDevice, int32 unit, uint32 blockOffset);

/*
 * Private routines.
 */
struct IOReq *BarfReadCallback(struct IOReq *iorP);
struct IOReq *BarfWriteCallback(struct IOReq *iorP);
static void BarfDiskCloseFile(File *theFile);

static void GetSequenceNum(ServerRequest *req, BarfDisk *disk);
static void ReleaseSequenceNum(ServerRequest *req, BarfDisk *disk);
static Err SubmitServerRequest(ServerRequest *req, WorkOrder *wo);
static Err SmartRetryServerRequest(BarfDisk *theDevice, ServerRequest *req);
static void SetPageBits(uint32 *pageBits, uint32 blocks);
#ifdef DEBUG
void static PrintPageBits(uint32 *pageBits);
#endif
static void UpdatePageBits(uint32 *pageBits, uint32 missingPageLow,
  uint32 missingPageHigh);
static void WorkOrderDone(WorkOrder *wo);
static void BarfToDirectoryEntry(FileIOReq *fileIOReq, uchar *data);
static void UpdateTimeOut(uchar barfOp, int32 observedDelay);
static int32 FirstIDSet(uint32 *table, int32 count);
static void ProcessReply(ServerReply *reply, BarfDisk *theDevice);
static int MissingPageRange(uint32 *pageBits, uint32 *low, uint32* high);



static const TagArg filesystemArgs[] = {
  { FILESYSTEM_TAG_PRI,     (void *)1, },
  { FILESYSTEM_TAG_END,     0, },
};

static const TagArg fsDevArgs[] = {
  { TAG_ITEM_PRI,             (void *)1, },
  { CREATEDEVICE_TAG_DRVR,    NULL },
  { TAG_ITEM_NAME,           "filesystem" },
  { TAG_END,                  0, },
};

Err BARF_to_error [] = {
  0,
  MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_NoFile), /* End of directory */
  MakeFErr(ER_SEVER,ER_C_STND,ER_SoftErr),    /* Invalid parent handle */
  MakeFErr(ER_SEVER,ER_C_STND,ER_SoftErr),    /* Invalid directory handle */
  MakeFErr(ER_SEVER,ER_C_STND,ER_SoftErr),    /* Invalid file handle */
  MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_NoFile), /* Directory doesn't exist */
  MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_NoFile), /* File doesn't exist */
  MakeFErr(ER_SEVER,ER_C_STND,ER_BadIOArg),   /* Invalid block number */
  MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_Busy),    /* Open limit exceeded */
  MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_Busy),    /* Server of resources (?) */
  MakeFErr(ER_SEVER,ER_C_STND,ER_BadIOArg),   /* Invalid directory key */
  MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_DeviceError), /* File read error  */
  MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_DeviceError), /* Directory read error  */
  MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_Damaged), /* File open error */
  MakeFErr(ER_SEVER,ER_C_STND,ER_SoftErr),    /* Invalid transaction ID */
  MakeFErr(ER_SEVER,ER_C_STND,ER_NotPrivileged), /* Invalid access */
  MakeFErr(ER_SEVER,ER_C_STND,ER_SoftErr),    /* Invalid operation */
  MakeFErr(ER_SEVER,ER_C_STND,ER_BadIOArg)    /* End of file */
};

extern char *fsCacheBase;
extern List fsCacheList;


const int32 BarfRequestLengths[RF_END+1] =
{
  3             /*  RF_START           */ ,
  37		/*  RF_DIRECTORY_OPEN  */ ,
  4		/*  RF_DIRECTORY_CLOSE */ ,
  8		/*  RF_DIRECTORY_READ  */ ,
  37		/*  RF_FILE_OPEN       */ ,
  4		/*  RF_FILE_CLOSE      */ ,
  7		/*  RF_FILE_READ       */ ,
  8		/*  RF_MULTI_READ      */ ,
  4		/*  RF_GET_FILE_SIZE   */ ,
  3             /*  Unused code 0x9    */ ,
  3             /*  Unused code 0xA    */ ,
  3             /*  Unused code 0xB    */ ,
  3             /*  Unused code 0xC    */ ,
  3             /*  Unused code 0xD    */ ,
  3             /*  Unused code 0xE    */ ,
  3		/*  RF_END             */
};


#ifndef PRODUCTION
extern void MySysErr(Err err);
#endif

/*
 * Delete item if was allocated.
 */
static void
Nuke(void *foo) {
  if (foo) {
    SuperDeleteItem(((ItemNode *)foo)->n_Item);
  }
}

#ifdef LATER
void ValidateList(List *l, char *name)
{
  int32 interrupts;
  Node *n;
  interrupts = Disable();
  if (l->ListAnchor.head.links.flink == &l->ListAnchor.tail.links) {
    if (l->ListAnchor.tail.links.blink != &l->ListAnchor.head.links ||
	l->ListAnchor.tail.links.flink != NULL) {
      Enable(interrupts);
      DBUG0(("Corrupt null list %s at 0x%X\n", name, l));
      return;
    }
    Enable(interrupts);
    return;
  }
  n = FirstNode(l);
  if (!n) {
    Enable(interrupts);
    DBUG0(("Null head of %s at 0x%X\n", name, l));
    return;
  }
  while (n) {
    if (n == ((Node *) &l->ListAnchor.tail.links.blink)) {
      if (n->
#endif

  

/*
   Acquire or allocate a server request, and manage the window
*/
static ServerRequest *
GetServerRequest(BarfDisk *disk)
{
  ServerRequest *req;
  IOReq *ioReq;
  Item ioReqItem;
  TagArg ioReqTags[2];

  if (SERVER_WINDOW_FULL(disk)) {
    DBUG(("Window of %d is full [%d, %d]\n", disk->bd_ServerWindowSize,
	  disk->bd_NextSequenceNumber, disk->bd_OldestSequenceNumber));
    return NULL;
  }

  if (!IsEmptyList(&disk->bd_ServerRequestsFree)) {
    req = (ServerRequest *) FirstNode(&disk->bd_ServerRequestsFree);
    RemNode((Node *) req);
    DBUG(("Re-using request at 0x%X\n", req));
  } else {
    req = (ServerRequest *) AllocMem(sizeof (ServerRequest), MEMTYPE_FILL);
    if (!req) {
      DBUG(("Unable to allocate server request\n"));
      return NULL;
    }
    DBUG(("Allocated new request at 0x%X\n", req));

    /*
     * If we're running in a thread which hasn't opened
     * the NetDevice, we need to open it before we
     * can create an IOReq.
     */
    if (CURRENTTASK == fileFolio->ff_Daemon.ffd_Task) {
      if (!(disk->bd_Flags & BARF_FLG_DAEMON_DISK_OPEN)) {
	Err err;

	err = SuperOpenItem(disk->bd_NetDevice->dev.n_Item, 0);
	if (err < 0) {
	  DBUG(("Unable to open NetDevice in daemon\n"));
	  return NULL;
	}
	disk->bd_Flags |= BARF_FLG_DAEMON_DISK_OPEN;
	DBUG(("Opened NetDevice in daemon\n"));
      }
    }

    ioReqTags[0].ta_Tag = CREATEIOREQ_TAG_DEVICE;
    ioReqTags[0].ta_Arg = (void *) disk->bd_NetDevice->dev.n_Item;
    ioReqTags[1].ta_Tag = TAG_END;
    DBUG(("Getting IOReq for device-item 0x%X at 0x%X\n",
	  disk->bd_NetDevice->dev.n_Item, disk->bd_NetDevice));
    ioReqItem = SuperCreateItem(MKNODEID(KERNELNODE,IOREQNODE), ioReqTags);
    if (ioReqItem < 0) {
      FreeMem(req, sizeof (ServerRequest));
      DBUG(("Unable to allocate IOReq\n"));
      MySysErr(ioReqItem);
/*      disk->bd_Trouble = TRUE; */
      return NULL;
    }
    req->req_IOReq = ioReq = (IOReq *) LookupItem(ioReqItem);
    GiveDaemon(ioReq);
    memset(&ioReq->io_Info, 0, sizeof ioReq->io_Info);
    ioReq->io_Info.ioi_Command = CMD_WRITE;
    ioReq->io_Info.ioi_Unit = disk->bd_NetUnit;
    ioReq->io_Info.ioi_Send.iob_Buffer = &req->req_Barf;
    ioReq->io_Info.ioi_User = (uint32) req;
    ioReq->io_CallBack = BarfWriteCallback;
  }
  memset(&req->req_PageBits, 0, sizeof req->req_PageBits);
  memset(&req->req_Barf, 0, sizeof req->req_Barf);
#ifdef DO_SMART_RETRY
  req->req_Flags = 0;
#endif
  req->req_WorkOrder = NULL;
  req->req_TimeoutStart = req->req_TimeoutLimit = req->req_FileUniqueID =
    req->req_PagesPending = 0;
  req->req_Flags = 0;
#ifdef DO_REQ_STATS
    req->req_TotalTime = req->req_MaxTime = req->req_Pages = 0;
#endif

  GetSequenceNum(req, disk);

  req->req_Phase = REQUEST_IDLE;
  req->req_IOReq->io_Info.ioi_Send.iob_Len = 0; /* Fill in later! */
  return req;
}

/*
   Release a server request, and update the window range
*/
static void
ReleaseServerRequest (ServerRequest *req, BarfDisk *disk)
{
  int32 interrupts;

  DBUG(("Releasing request at 0x%X\n", req));
  interrupts = Disable();
  req->req_Phase = REQUEST_IDLE;
  AddTail(&disk->bd_ServerRequestsFree, (Node *) req);
  Enable(interrupts);
  ReleaseSequenceNum(req, disk);
}

/*
 * Update the sequence number data to reflect the fact
 * that we're releasing a request and so retiring its
 * sequence number.
 */
static void
ReleaseSequenceNum(ServerRequest *req, BarfDisk *disk)
{
  int32 mask, oldest;

  mask = disk->bd_SequenceTableSize - 1;
  disk->bd_ServerRequestsOutstanding[req->req_SequenceNumber & mask] = NULL;
  oldest = disk->bd_OldestSequenceNumber;

  if (!(BARF_REQ_WAS_SENT(req)) &&
      req->req_SequenceNumber + 1 == disk->bd_NextSequenceNumber) {
    -- disk->bd_NextSequenceNumber; /* didn't use, recycle immediately */
  }

  while (oldest < disk->bd_NextSequenceNumber) {
    if (disk->bd_ServerRequestsOutstanding[oldest & mask]) {
      break;
    } else {
      oldest ++;
    }
  }

  disk->bd_OldestSequenceNumber = oldest;
  DBUG(("Sequence window base is now %d\n", oldest));
}

/*
 * Allocate a new sequence number.
 * Updates global sequence number data,
 * plus req->req_SequenceNumber and req->req_Barf.br_Seq*
 */
static void
GetSequenceNum(ServerRequest *req, BarfDisk *disk)
{
  register uint32 seqno;

  seqno = req->req_SequenceNumber = disk->bd_NextSequenceNumber++;
  disk->bd_ServerRequestsOutstanding[seqno &
				     (disk->bd_SequenceTableSize - 1)] = req;
  req->req_Barf.br_SeqMSB = (uint8) (seqno>>8);
  req->req_Barf.br_SeqLSB = (uint8)  seqno;
}


/*
 * Submit a ServerRequest on behalf of a WorkOrder:
 * chain ServerRequest into list of requests issued for
 * the WorkOrder and push it out on the wire.
 */
static Err
SubmitServerRequest (ServerRequest *req, WorkOrder *wo)
{
  Err err;
  int32 interrupts;
  IOReq *ioReq;

#ifdef STOP_AFTER_TIMEOUT
  if (stop_after_timeout_flag)
    return (0);
#endif
  req->req_WorkOrder = wo;
  interrupts = Disable();
  AddTail(&wo->wo_RequestsSubmitted, (Node *) req);
  wo->wo_NumRequestsSubmitted ++;
  req->req_Phase = REQUEST_SENDING;
  req->req_TimeoutStart =
    fileFolio->ff_Daemon.ffd_TimerDevice->timerdev_VBlankCount;
  req->req_TimeoutLimit = BARF_WRITE_TIMEOUT;
  req->req_Flags &= ~BARF_REQ_WAS_SENT_FLAG;
  Enable(interrupts);
  DBUG(("Sending server request seq %d\n", req->req_SequenceNumber));
  ioReq = req->req_IOReq;
  if (ioReq->io_Info.ioi_Send.iob_Len == 0) {
    ioReq->io_Info.ioi_Send.iob_Len = 
      BarfRequestLengths[BARF_REQ_OP(req)];
  }
  err = SuperinternalSendIO(ioReq);
  if (err < 0) {
    qprintf(("OOPS!  Server request-send got an error\n"));
    MySysErr(err);
  } else {
    DBUG(("Sent\n"));
    req->req_Flags |= BARF_REQ_WAS_SENT_FLAG;
    busyTimer = 0;
  }

  /* stress test fu */
  if (FSPARAM_WRT_BASH) {
    /* send it out a few times for stress testing */
    int i;
    Err err;

    for (i = 0; i < 5; i++) {
      err = SuperinternalSendIO(ioReq);
      if (err < 0) {
	qprintf(("bashing wrt: "));
	MySysErr(err);
      }
    }
  }
  return err;
}

/*
 * Get and initialize a WorkOrder;
 * take from free list if available,
 * else allocate memory.
 */
static WorkOrder *
GetWorkOrder(BarfDisk *disk)
{
  WorkOrder *wo;
  int32 interrupts;
  DBUG2(("Getting work order\n"));
  DBUG2(("In-use at 0x%X head 0x%X tail 0x%X\n", &disk->bd_WorkOrdersInUse,
	FirstNode(&disk->bd_WorkOrdersInUse),
	LastNode(&disk->bd_WorkOrdersInUse)));
  DBUG2(("Free list at 0x%X head 0x%X tail 0x%X\n", &disk->bd_WorkOrdersFree,
	FirstNode(&disk->bd_WorkOrdersFree),
	LastNode(&disk->bd_WorkOrdersFree)));
  interrupts = Disable();
  if (!IsEmptyList(&disk->bd_WorkOrdersFree)) {
    wo = (WorkOrder *) FirstNode(&disk->bd_WorkOrdersFree);
    RemNode((Node *) wo);
  } else {
    wo = (WorkOrder *) AllocMem(sizeof (WorkOrder), MEMTYPE_FILL);
    if (!wo) {
      Enable(interrupts);
      return NULL;
    }
    InitList(&wo->wo_RequestsSubmitted, NULL);
    wo->wo_Disk = disk;
  }
  wo->wo_FileIOReq = NULL;
  wo->wo_Error = 0;
  wo->wo_Aborted = wo->wo_NeedsAttention = wo->wo_Done = 0;
  wo->wo_LowPage = wo->wo_HighPage = wo->wo_PageCount =
    wo->wo_FirstUnrequestedPage = wo->wo_NumRequestsSubmitted = 0;
  AddTail(&disk->bd_WorkOrdersInUse, (Node *) wo);
  Enable(interrupts);
  DBUG2(("Got workorder at 0x%X\n", wo));
  DBUG2(("Node flink now 0x%X blink 0x%X\n", NextNode(wo), PrevNode(wo)));
  DBUG2(("In-use at 0x%X head 0x%X tail 0x%X\n", &disk->bd_WorkOrdersInUse,
	FirstNode(&disk->bd_WorkOrdersInUse),
	LastNode(&disk->bd_WorkOrdersInUse)));
  DBUG2(("Free list at 0x%X head 0x%X tail 0x%X\n", &disk->bd_WorkOrdersFree,
	FirstNode(&disk->bd_WorkOrdersFree),
	LastNode(&disk->bd_WorkOrdersFree)));
  return wo;
}

/*
 * Put the WorkOrder on the free list.
 */
static void 
ReleaseWorkOrder(WorkOrder *wo, BarfDisk *disk)
{
  ServerRequest *req;
  int32 interrupts;
  DBUG(("Releasing workorder at 0x%X\n", wo));
  interrupts = Disable();
  RemNode((Node *) wo);
  AddTail(&disk->bd_WorkOrdersFree, (Node *) wo);
  Enable(interrupts);
  DBUG2(("Node flink now 0x%X blink 0x%X\n", NextNode(wo), PrevNode(wo)));
  DBUG2(("In-use at 0x%X head 0x%X tail 0x%X\n", &disk->bd_WorkOrdersInUse,
	FirstNode(&disk->bd_WorkOrdersInUse),
	LastNode(&disk->bd_WorkOrdersInUse)));
  DBUG2(("Free list at 0x%X head 0x%X tail 0x%X\n", &disk->bd_WorkOrdersFree,
	FirstNode(&disk->bd_WorkOrdersFree),
	LastNode(&disk->bd_WorkOrdersFree)));
  while (!IsEmptyList(&wo->wo_RequestsSubmitted)) {
    req = (ServerRequest *) FirstNode(&wo->wo_RequestsSubmitted);
    RemNode((Node *) req);
    ReleaseServerRequest(req, disk);
  }
}

/*
 * Get and initialize a ServerReply
 * take from free list if available,
 * else allocate memory.
 */
static ServerReply *
GetServerReply(BarfDisk *disk)
{
  ServerReply *reply;
  IOReq *ioReq;
  Item ioReqItem;
  TagArg ioReqTags[2];
  if (!IsEmptyList(&disk->bd_ServerRepliesFree)) {
    reply = (ServerReply *) FirstNode(&disk->bd_ServerRepliesFree);
    RemNode((Node *) reply);
  } else {
    reply = (ServerReply *) AllocMem(sizeof (ServerReply), MEMTYPE_FILL);
    if (!reply) {
      return NULL;
    }
    ioReqTags[0].ta_Tag = CREATEIOREQ_TAG_DEVICE;
    ioReqTags[0].ta_Arg = (void *) disk->bd_NetDevice->dev.n_Item;
    ioReqTags[1].ta_Tag = TAG_END;
    ioReqItem = SuperCreateItem(MKNODEID(KERNELNODE,IOREQNODE), ioReqTags);
    if (ioReqItem < 0) {
      DBUG(("Could not create server-reply IOReq\n"));
      MySysErr(ioReqItem);
      return NULL;
    }
    reply->reply_IOReq = ioReq = (IOReq *) LookupItem(ioReqItem);
    GiveDaemon(ioReq);
    reply->reply_Disk = disk;
    memset(&ioReq->io_Info, 0, sizeof ioReq->io_Info);
    ioReq->io_Info.ioi_Command = CMD_READ;
    ioReq->io_Info.ioi_Unit = disk->bd_NetUnit;
    ioReq->io_Info.ioi_Recv.iob_Buffer = &reply->reply_Barf;
    ioReq->io_Info.ioi_Recv.iob_Len = sizeof (reply->reply_Barf);
    ioReq->io_Info.ioi_User = (uint32) reply;
    ioReq->io_CallBack = BarfReadCallback;
  }
  return reply;
}

#if 0
/* this routine is not used, but leave in the source in case it is needed. */

/*
 * Put the ServerReply on the free list.
 */
static void
ReleaseServerReply (ServerReply *reply, BarfDisk *disk)
{
  DBUG2(("Releasing the reply at 0x%X\n", reply));
  AddTail(&disk->bd_ServerRepliesFree, (Node *) reply);
}
#endif

/*
 * "QueueRequest" Barf fs driver entry point:
 * validate request & add to RequestsToDo list.
 */
int32
QueueBarfDiskRequest(BarfDisk *theDevice, IOReq *theRequest)
{
  uint32 interrupts;
  File *theFile;
  DBUG(("Queue BARF I/O\n"));
  switch (theRequest->io_Info.ioi_Command) {
  case CMD_READ:
    theFile = ((OpenFile *) theRequest->io_Dev)->ofi_File;
    if (theRequest->io_Info.ioi_Recv.iob_Len % theFile->fi_BlockSize != 0) {
      return MakeFErr(ER_SEVER,ER_C_STND,ER_BadPtr);
    }
    break;
  case FILECMD_READDIR:
  case FILECMD_READENTRY:
    if (theRequest->io_Info.ioi_Recv.iob_Buffer == NULL) {
      return MakeFErr(ER_SEVER,ER_C_STND,ER_BadPtr);
    }
    break;
  case FILECMD_OPENENTRY:
    break;
  default:
    return MakeFErr(ER_SEVER,ER_C_STND,ER_BadCommand);
  }

#ifdef PROFILE_DISK_REQUEST
  if (theRequest->io_Info.ioi_Command == CMD_READ) {
    register int i;
    
    for (i = 0; i < N_DISK_REQ_STATS; i++) {
      /* if we can find a blank slot, great, otherwise punt */
      if (diskReqStats[i].ioReq == NULL) {
	diskReqStats[i].ioReq = &(theRequest->io_Info);
	TimeStamp(&(diskReqStats[i].start));
	/* 
	 * DEBUG
	 * printf(("recording 0x%x\n", &(theRequest->io_Info)));
	 */
	break;
      }
    }
  }
#endif /* PROFILE_DISK_REQUEST */

  interrupts = Disable();
  InsertNodeFromTail(&theDevice->bd.hdi_RequestsToDo, (Node *) theRequest);
  theRequest->io_Flags &= ~IO_QUICK;
  Enable(interrupts);
  return 0;
}

/*
 * Signal the file daemon that we would like to have
 * another read started, using this newly-available ServerReply.
 */
static Err
StartReadOn(ServerReply *reply)
{
  int32 interrupts;
  Err err;
  DBUG(("Starting reader"));
#ifdef ZAP_REPLY_BUFFER
  memset(reply->reply_Barf.br_Buffer, '#', BARF_REPLY_BUFFER_SIZE);
#endif
  interrupts = Disable();
  AddTail(&reply->reply_Disk->bd_ServerRepliesReading, (Node *) reply);
  Enable(interrupts);
  DBUG2(("Sending reader IOReq\n"));
  err = SuperinternalSendIO(reply->reply_IOReq);
  if (err < 0) {
    qprintf((" - error!\n"));
    MySysErr(err);
  } else {
    DBUG((".. ok\n"));
  }
  return err;
}

/*
 * Dispose of the WorkOrder: signal process that
 * made IO request that we're done and free
 * the WorkOrder.
 */
static void
WorkOrderDone(WorkOrder *wo)
{
  FileIOReq *fileIOReq;
  int32 interrupts;

  fileIOReq = wo->wo_FileIOReq;

  if (fileIOReq) {
    fileIOReq->fio.io_Error = wo->wo_Error;

#ifdef PROFILE_DISK_REQUEST
    if (fileIOReq->fio.io_Info.ioi_Command == CMD_READ) {
      register int i;
      struct timeval stop;
    
      for (i = 0; i < N_DISK_REQ_STATS; i++) {
	/*
	 * if we can find the matching entry, then record stats,
	 * else punt.
	 */
	/* DEBUG */
#if 0
	qprintf(("checking 0x%x against 0x%x\n",
		 diskReqStats[i].ioReq, &(fileIOReq->fio.io_Info)));
#endif
	if (diskReqStats[i].ioReq == &(fileIOReq->fio.io_Info)) {
	  diskReqStats[i].ioReq = NULL;	/* mark as reusable */
	  TimeStamp(&stop);

	  stop.tv_sec -= diskReqStats[i].start.tv_sec;
	  stop.tv_usec -= diskReqStats[i].start.tv_usec;
	  if (stop.tv_usec < 0) {
	     stop.tv_sec--;
	     stop.tv_usec += 1000000;
	  }
	  /* DEBUG */
	  qprintf(("time= %d secs, %d usecs num blocks %d\n",
		   stop.tv_sec, stop.tv_usec,
		   fileIOReq->fio.io_Info.ioi_Recv.iob_Len / 512));

	  diskReqTotalTime.tv_sec += stop.tv_sec;
	  diskReqTotalTime.tv_usec += stop.tv_usec;
	  if (diskReqTotalTime.tv_usec >= 1000000) {
	     diskReqTotalTime.tv_sec++;
	     diskReqTotalTime.tv_usec -= 1000000;
	  }
	  diskReqTotalBlocks +=
	    fileIOReq->fio.io_Info.ioi_Recv.iob_Len / 512;

	  /* DEBUG */
	  qprintf(("total time %d secs, %d usecs, blocks %d\n",
		   diskReqTotalTime.tv_sec, diskReqTotalTime.tv_usec,
		   diskReqTotalBlocks));
	  break;
	}
      }

      if (numstats++ > 32) {
	qprintf(("*** barfstats time %d secs %d usecs blocks %d\n",
		 diskReqTotalTime.tv_sec,
		 diskReqTotalTime.tv_usec,
		 diskReqTotalBlocks));
	numstats = 0;
      }
    }
#endif /* PROFILE_DISK_REQUEST */

    interrupts = Disable();
    RemNode((Node *) fileIOReq);
    Enable(interrupts);
    
    (void) SuperCompleteIO((IOReq *) fileIOReq);
  }
  ReleaseWorkOrder(wo, wo->wo_Disk);
}

/*
 * "AbortIO" Barf fs driver entry point:
 * mark its corresponding WorkOrder as "aborted". 
 */
void
AbortBarfDiskIo(IOReq *theRequest)
{
  WorkOrder *wo;
  BarfDisk *theDevice;
  int32 interrupts;
  theDevice = (BarfDisk *) ((OpenFile *) theRequest->io_Dev)->ofi_File->fi_FileSystem->fs_Device;
  interrupts = Disable();
  wo = (WorkOrder *) FirstNode(&theDevice->bd_WorkOrdersInUse);
  while (IsNode(&theDevice->bd_WorkOrdersInUse,wo)) {
    if (theRequest == (IOReq *) wo->wo_FileIOReq) {
      wo->wo_Aborted = TRUE;
      break;
    }
    wo = (WorkOrder *) NextNode(wo);
  }
  Enable(interrupts);
}  

/*
 * Map a Barf directory entry to the canonical
 * "DirectoryEntry" form.
 */
static void
BarfToDirectoryEntry(FileIOReq *fileIOReq, uchar *data)
{
  DirectoryEntry de;
  int32 deSize;
  int32 blockSize;
  strncpy(de.de_FileName, (char *) data+5, FILESYSTEM_MAX_NAME_LEN);
  de.de_UniqueIdentifier = 0;
  de.de_BlockSize =
    blockSize =
      ((OpenFile *) fileIOReq->fio.io_Dev)->ofi_File->fi_FileSystem->fs_VolumeBlockSize;
  de.de_Burst = -1;
  de.de_Gap = -1;
  de.de_AvatarCount = -1;
  if (data[4] == 'D') {
    de.de_Type = FILE_TYPE_DIRECTORY;
    de.de_ByteCount = 0;
    de.de_BlockCount = 0;
    de.de_Flags = FILE_IS_DIRECTORY | FILE_IS_READONLY |
      FILE_IS_FOR_FILESYSTEM |
	FILE_SUPPORTS_DIRSCAN |
	  FILE_SUPPORTS_ENTRY;
  } else {
    de.de_Type = 0x20202020;
    memcpy(&de.de_ByteCount, data, 4);
    de.de_BlockCount = (de.de_ByteCount + blockSize - 1) / blockSize;
    de.de_Flags = FILE_IS_READONLY;
  }
  de.de_Location = 0;
  deSize = fileIOReq->fio.io_Info.ioi_Recv.iob_Len;
  if (deSize > sizeof (DirectoryEntry)) {
    deSize = sizeof (DirectoryEntry);
  }
  memcpy(fileIOReq->fio.io_Info.ioi_Recv.iob_Buffer, &de, deSize);
  fileIOReq->fio.io_Actual = deSize;
}

static int32
FirstIDSet(uint32 *table, int32 count) {
  int32 word, index;
  uint32 bits, mask;
  word = 0;

  while (--count >= 0) {
    if ((bits = table[word]) != 0) {
      index = word * 32;
      mask = (uint32) 0x80000000;
      while ((bits & mask) == 0) {
	index ++;
	mask = mask >> 1;
      }
      DBUG(("ID hit, word %d index %d mask 0x%08X\n", word, index, mask));
      table[word] &= ~mask;
      return index;
    }
    word++;
  }
  return -1;
}

/*
 * Set the bit vector to reflect the 
 * contiguous range of blocks we're requesting.
 */
static void
SetPageBits(uint32 *pageBits, uint32 blocks)
{
  register int i;

  for (i = 0; i < BARF_PAGE_BITS_SIZE && blocks > 0; i++) {
    if (blocks >= 32) {
      /* can fill entire uint32 with ones */
      pageBits[i] = 0xFFFFFFFF;
    } else {
      /* end of bit vector */
      pageBits[i] = ((uint32) 0xFFFFFFFF) << (32 - blocks);
      break;
    }
    blocks -= 32;
  }
}

/*
 * Take a reply from the server and process it appropriately:
 * for example, in the case of a succesfully compeleted read,
 * copy the returned data in the IO request buffer.
 */
static void
ProcessReply(ServerReply *reply, BarfDisk *theDevice)
{
  int32 seqno;
  ServerRequest *req;
  WorkOrder *wo;
  FileIOReq *fileIOReq;
  OpenFile *openFile;
  File *theFile, *childFile;
  IoCacheEntry *entry;
  FileSystem *fs;
  int32 bufOffset;
  int32 status;
  int32 octets;
  int32 blockBase;
  int32 blockCount;
  int32 requestBase;
  int32 index;
  uint32 blockSize;
  uint32 mask, pageMask;
  uint32 page;
  uint32 temp;
  int32 entryNum, offset, nextKey, hit;
  int32 i;
  uchar *data;
  char fileName[32];
  uint32 timeDelta;

  mask = theDevice->bd_SequenceTableSize - 1;
  seqno = (((uint32) reply->reply_Barf.br_SeqMSB) << 8) +
    reply->reply_Barf.br_SeqLSB;

  DBUG(("."));
  DBUG(("Process reply 0x%X seq %d type %d\n", reply, seqno,
	  reply->reply_Barf.br_OperationType));

  req = theDevice->bd_ServerRequestsOutstanding[seqno & mask];
  if (!req) {
    if (reply->reply_Barf.br_OperationType & BARF_RETRY_MASK) {
      DBUG(("Stale retry received for seq %d... excessive latency?\n",
	     seqno));
    } else {
      DBUG(("Stale non-retry received for seq %d\n", seqno));
    }
    DBUG(("Reply was code %d status %d\n",
	   BARF_REPL_OP(reply), reply->reply_Barf.br_Status));
    return;
  } else if ((req->req_SequenceNumber & 0x0000FFFF) != seqno) {
    DBUG0(("Out-of-window reply for seq %d!\n", seqno));
    return;
  } else {
    DBUG(("Request structure at 0x%X\n", req));
  }

  fs = theDevice->bd_FileSystem;
  wo = req->req_WorkOrder;
  DBUG(("Work order is at 0x%X\n", wo));

  fileIOReq = wo->wo_FileIOReq;
  DBUG(("Original I/O request is at 0x%X\n", fileIOReq));
  if (fileIOReq) {
    openFile = (OpenFile *) fileIOReq->fio.io_Dev;
    theFile = openFile->ofi_File;
  } else {
    openFile = NULL;
    theFile = NULL;
  }

  req->req_Phase = REQUEST_RECEIVING;
  status = reply->reply_Barf.br_Status;
  if (BARF_REPL_OP(reply) != BARF_REQ_OP(req)) {
    qprintf(("BARF server sent reply %d for request %d\n",
	       BARF_REPL_OP(reply), BARF_REQ_OP(req)));
    wo->wo_Error = MakeFErr(ER_SEVER,ER_C_STND,ER_SoftErr);
    wo->wo_Done = TRUE;
    return;
  }

  DBUG(("Process code %d\n", reply->reply_Barf.br_OperationType));

  timeDelta = fileFolio->ff_Daemon.ffd_TimerDevice->timerdev_VBlankCount
    - req->req_TimeoutStart;

  if (BARF_REPL_OP(reply) != RF_MULTI_READ) {
    /*
     * Update the timeout value for this type command with
     * the time it took to get a reply for this command.
     * This calculation is more complicated for multireads,
     * and is done in the multiread process code in the
     * switch statement below.
     */
#ifndef STOP_AFTER_TIMEOUT
    UpdateTimeOut(BARF_REPL_OP(reply), timeDelta);
#endif
  }

  switch (BARF_REPL_OP(reply)) {
  case RF_START:
    DBUG(("RF_START response\n"));
    if (status != RF_SUCCESS) {
	qprintf(("BARF error code %d on START\n", status));
	wo->wo_Error = BARF_to_error[status];
	wo->wo_Done = TRUE;
	return;
    }
    memcpy(&temp, &reply->reply_Barf.br_Buffer[0], 4);
    fs->fs_VolumeBlockSize = temp;
    fs->fs_RootDirectory->fi_BlockSize = temp;
    DBUG(("Volume block size is %d\n", temp));
    temp = (((int32) reply->reply_Barf.br_Buffer[4]) << 8) +
	reply->reply_Barf.br_Buffer[5];
    if (theDevice->bd_ServerWindowSize > temp) {
	theDevice->bd_ServerWindowSize = temp;
    }
    DBUG(("Server reports window size is %d, using %d\n", temp,
	    theDevice->bd_ServerWindowSize));
    fs->fs_Flags &= ~FILESYSTEM_NOT_READY; /* hang out the shingle */
    DBUG(("Marking work order done!\n"));
    wo->wo_Done = TRUE;
    qprintf(("/%s is open for business,", fs->fs_FileSystemName));
    qprintf((" seq window %d file window %d burst %d\n",
	       theDevice->bd_ServerWindowSize, MULTIREAD_WINDOW_SIZE,
	       MULTIREAD_BLOCK_LIMIT));
    qprintf(("fsParams 0x%x\n", (void *)fsParams));
#ifdef TRACE_REPLIES
    qprintf(("reply_trace_buf 0x%x\n", (void *)reply_trace_buf));
#endif
    break;

  case RF_FILE_READ:
    bufOffset = (req->req_LowPage - wo->wo_LowPage) * theFile->fi_BlockSize;
    octets = ((uint32) reply->reply_Barf.br_Buffer[0] << 8) +
	(uint32) reply->reply_Barf.br_Buffer[1];
    DBUG(("RF_FILE_READ reply, offset %d octets %d\n", bufOffset, octets));
    if (status == RF_END_OF_FILE) {
      DBUG(("Got end-of-file!\n"));
    }
    if (status != RF_SUCCESS && (status != RF_END_OF_FILE || octets == 0)) {
	qprintf(("BARF error code %d on FILE_READ\n", status));
	wo->wo_Error = BARF_to_error[status];
	wo->wo_Done = TRUE;
	return;
    }
    if (bufOffset < 0 ||
	  bufOffset + octets > fileIOReq->fio.io_Info.ioi_Recv.iob_Len) {
	qprintf(("BARF server sent out-of-range FILE_READ!\n"));
	wo->wo_Done = TRUE;
	break;
    }
    memcpy((uchar *) fileIOReq->fio.io_Info.ioi_Recv.iob_Buffer + bufOffset,
	     &reply->reply_Barf.br_Buffer[2],
	     octets);
    blockSize = theFile->fi_BlockSize;
    if (octets < blockSize) {
      octets = blockSize; /* last-block fakeout */
    }
    fileIOReq->fio.io_Actual += octets;
    wo->wo_Done = TRUE;
    break;

  case RF_MULTI_READ:
#ifdef DO_REQ_STATS
    /* if this is a non-smart-retry, add time delta to stats */
    if (!BARF_REQ_IS_SMART_RETRY(req)) {
      /*
       * Record the sum of all elapsed times for this request
       * and the longest delay we've seen.
       */
      uint32 timeDelta;

      timeDelta = fileFolio->ff_Daemon.ffd_TimerDevice->timerdev_VBlankCount
	- req->req_TimeoutStart;
#if 0
      qprintf(("debug: timeDelta %d TimeoutStart %d\n",
	       timeDelta, req->req_TimeoutStart));
#endif
      req->req_TotalTime += timeDelta;
      /*
       * current time (and thus timeDelta) are always greater than
       * recorded req_MaxTime, as time doesn't go backwards.
       */
      req->req_MaxTime = timeDelta;
    }
#endif /* DO_REQ_STATS */

    blockCount = reply->reply_Barf.br_Buffer[0];
    blockBase = ((uint32) reply->reply_Barf.br_Buffer[1] << 16) +
   	          ((uint32) reply->reply_Barf.br_Buffer[2] <<  8) +
                 (uint32) reply->reply_Barf.br_Buffer[3];
    octets = ((uint32) reply->reply_Barf.br_Buffer[6] << 8) +
	        (uint32) reply->reply_Barf.br_Buffer[7];

    DBUG(("RF_MULTI_READ reply, block %d count %d octets %d\n",
	    blockBase, blockCount, octets));
    if (status == RF_END_OF_FILE) {
      DBUG(("Got end-of-file!\n"));
    }
    if (status != RF_SUCCESS && (status != RF_END_OF_FILE || octets == 0)) {
	qprintf(("BARF error code %d on MULTI_READ\n", status));
	wo->wo_Error = BARF_to_error[status];
	wo->wo_Done = TRUE;
	return;
    }
    if (req != theDevice->bd_ServerRequestsOutstanding[seqno & mask]) {
	DBUG(("OOPS!  Stomp 1 in multiread!\n"));
    }

    blockSize = theFile->fi_BlockSize;
    bufOffset = (blockBase - wo->wo_LowPage) * blockSize;
    if (bufOffset < 0 ||
	  bufOffset + octets > fileIOReq->fio.io_Info.ioi_Recv.iob_Len) {
	qprintf(("BARF server sent out-of-range MULTI_READ!\n"));
	wo->wo_Done = TRUE;
	break;
    }
    requestBase = blockBase - req->req_LowPage;
    data = &reply->reply_Barf.br_Buffer[8];
    if (octets + 12 != reply->reply_IOReq->io_Actual) {
	qprintf(("AAGH!  Reply needed %d bytes total, got %d\n", octets+12,
		 reply->reply_IOReq->io_Actual));
    }

    while (octets > 0) {
	index = requestBase >> 5;
	pageMask = ((uint32) 0x80000000) >> (requestBase & 0x1F);
	DBUG(("Index %d mask 0x%X\n", index, pageMask));

	if (req->req_PageBits[index] & pageMask) {
	  req->req_PageBits[index] &= ~pageMask;
	  DBUG(("Moving %d bytes from 0x%X to 0x%X\n",
		(blockSize < octets) ? blockSize : octets,
		data,
		(uchar *) fileIOReq->fio.io_Info.ioi_Recv.iob_Buffer + bufOffset));
	  memcpy((uchar *) fileIOReq->fio.io_Info.ioi_Recv.iob_Buffer + bufOffset,
		 data, (blockSize < octets) ? blockSize : octets);
#ifdef ZAPREMAINDER
	  if (octets < blockSize) {
	    memset(octets + (uchar *) fileIOReq->fio.io_Info.ioi_Recv.iob_Buffer + bufOffset,
		   0, blockSize - octets);
	  }
#endif
	  req->req_PagesPending --;
	  wo->wo_PageCount --;
	  fileIOReq->fio.io_Actual += blockSize;
	  DBUG(("Pages remaining: request %d, workorder %d\n",
		req->req_PagesPending, wo->wo_PageCount));
	} else {
	  /*
	   * This is a duplicate reply, probably
	   * resulting from a premature retry.
	   */

	  if (BARF_REQ_IS_SMART_RETRY(req)) {
	    /*
	     * Extend timeout period by time delta of retry.
	     * This is a somewhat arbitrary number, but we
	     * need to back off the timeout period by a
	     * considerable amount, and an another round-trip
	     * is as good a number as any.
	     */
	    uint32 timeDelta;

	    timeDelta =
	      fileFolio->ff_Daemon.ffd_TimerDevice->timerdev_VBlankCount
		- req->req_TimeoutStart;
#if 0
	    qprintf(("debug: timeDelta %d TimeoutStart %d\n",
		     timeDelta, req->req_TimeoutStart));
#endif
	    req->req_TotalTime += timeDelta;

	    req->req_MaxTime += timeDelta;
	  }

	  qprintf(("Discarding duplicate reply 0x%X seq %d block %d\n",
		   reply, seqno,
		   blockBase));


	  DBUG(("Saw this page before, skip it\n"));
	}
	octets -= blockSize;
	data += blockSize;
	bufOffset += blockSize;
	requestBase ++;
	DBUG(("Octets remaining %d, data ptr now 0x%X, buffer offset %d\n",
	      octets, data, bufOffset));
    }
    if (req != theDevice->bd_ServerRequestsOutstanding[seqno & mask]) {
	DBUG(("OOPS!  Stomp 2 in multiread!\n"));
    }
    if (req->req_PagesPending == 0) {
	DBUG(("RF_MULTI_READ request completed\n"));

#ifdef DO_REQ_STATS
#if 0  
	/*
	 * Report statistics: the first, cheesy hack
	 * is to simply print them out.
	 * The right way to do this is probably to
	 * create statistic records categorized by
	 * number of blocks.  Concern is counting
	 */
	qprintf(("Request 0x%x seq %d total %d\n",
		 req, req->req_SequenceNumber & 0x0000FFFF,
		 req->req_TotalTime));
	qprintf(("  Pages %d avg %d max %d\n", req->req_Pages,
		 req->req_TotalTime/req->req_Pages, req->req_MaxTime));
#endif /* 0 */
#endif /* DO_REQ_STATS */

	/*
	 * Update timeout value if not a retry.
	 * Retries should not be counted, because
	 * retries ask for a (possibly very small)
	 * subset of the blocks previously requested,
	 * so the time to service the request may
	 * not be typical.
	 */
#ifndef STOP_AFTER_TIMEOUT
	if (!BARF_REQ_IS_RETRY(req))
	  UpdateTimeOut(BARF_REQ_OP(req), req->req_MaxTime);
#endif

	RemNode((Node *) req);
	ReleaseServerRequest(req, wo->wo_Disk);
	wo->wo_NumRequestsSubmitted --;
	if (wo->wo_PageCount == 0) {
	  wo->wo_Done = TRUE;
#ifdef TRACK_END_OF_FILE
	} else if (status == RF_END_OF_FILE) {
	  qprintf(("BARF tried to read past end-of-file on %s!\n",
		   theFile->fi_FileName));
	  qprintf((" %d pages remain to be read\n", wo->wo_PageCount));
	  wo->wo_Error = BARF_to_error[status];
	  wo->wo_Done = TRUE;
#endif
	} else {
	  wo->wo_NeedsAttention = TRUE;
	}
    } else if (wo->wo_PageCount == 0) {
      wo->wo_Done = TRUE;
    }
    break;
  case RF_DIRECTORY_READ:
    if (fileIOReq->fio.io_Info.ioi_Command == FILECMD_READENTRY) {
	memset(fileName, 0, sizeof fileName);
	i = (int32) fileIOReq->fio.io_Info.ioi_Send.iob_Len;
	if (i > 31) i = 31;
	memcpy(fileName, fileIOReq->fio.io_Info.ioi_Send.iob_Buffer, i);
    }
    octets = ((uint32) reply->reply_Barf.br_Buffer[0] << 8) +
	        (uint32) reply->reply_Barf.br_Buffer[1];
    memcpy(&nextKey, &reply->reply_Barf.br_Buffer[2], 4);
    DBUG(("RF_DIRECTORY_READ reply, nextkey %d octets %d\n",
	    nextKey, octets));
    if (status != RF_SUCCESS) {
	if (status != RF_END_OF_DIRECTORY) {
	  qprintf(("BARF error code on DIRECTORY_READ %d\n", status));
	  wo->wo_Error = BARF_to_error[status];
	  wo->wo_Done = TRUE;
	  return;
	}
	if (theFile->fi_BlockCount == 0) {
	  theFile->fi_BlockCount = wo->wo_LowPage + 1;
	  DBUG(("RF_END_OF_DIRECTORY, remember that there are %d page(s)\n",
		 theFile->fi_BlockCount));
	}
    }
    data = (uchar *) &reply->reply_Barf.br_Buffer[6];
    offset = 0;
    page = wo->wo_LowPage;
    index = entryNum = wo->wo_HighPage;
    DBUG(("This must be page %d, starting index %d\n", page, entryNum));
    hit = FALSE;
    while (offset < octets && !hit) {
	switch (fileIOReq->fio.io_Info.ioi_Command) {
	case FILECMD_READDIR:
	  if (entryNum == fileIOReq->fio.io_Info.ioi_Offset) {
	    hit = TRUE;
	  }
	  break;
	case FILECMD_READENTRY:
	  DBUG(("Compare %s with %s\n", fileName, (char *) data+offset+5));
	  if (strcasecmp(fileName, (char *) data+offset+5) == 0) {
	    hit = TRUE;
	  }
	  break;
	}
	if (!hit) {
	  DBUG2(("Skip past %s\n", (char *) data+offset+5));
	  entryNum ++;
	  offset += 6 + (int32) strlen((char *) data+offset+5);
	}
    }
    if (hit) {
	entry = FindCache(openFile, page);
	if (entry) {
	  DBUG(("Cache hit!  Move to head of list\n"));
	  entry->ioce.n_Priority = CACHE_PRIO_HIT;
	  RemNode((Node *) entry);
	  AddHead(&fsCacheList, (Node *) entry);
	} else {
	  DBUG(("Cache miss!  Submitting block %d to cache\n", page));
	  entry = AddCacheEntry(openFile, page, data, CACHE_PRIO_HIT,
				CACHE_BARF_DIRECTORY,
				octets);
	  if (entry) {
	    entry->ioce_CacheFirstIndex = wo->wo_HighPage;
	    entry->ioce_CacheMiscValue = nextKey;
	    DBUG(("Entry added, first index is %d, next key %d\n",
		  entry->ioce_CacheFirstIndex, entry->ioce_CacheMiscValue));
	  }
	}
	BarfToDirectoryEntry(fileIOReq, data+offset);
	wo->wo_Done = TRUE;
	break;
    }
    DBUG(("Miss!  Submitting block %d to cache\n", page));
    entry = AddCacheEntry(openFile, page, data, CACHE_PRIO_MISS,
			    CACHE_BARF_DIRECTORY,
			    octets);
    if (entry) {
	entry->ioce_CacheFirstIndex = wo->wo_HighPage;
	entry->ioce_CacheMiscValue = nextKey;
	DBUG(("Entry added, first index is %d, next key %d\n",
	      entry->ioce_CacheFirstIndex, entry->ioce_CacheMiscValue));
    }
    page ++;
    if (status == RF_END_OF_DIRECTORY ||
	  (theFile->fi_BlockCount > 0 && theFile->fi_BlockCount <= page)) {
	DBUG(("End of directory reached, report failure!\n"));
	wo->wo_Error = MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_NoFile);
	wo->wo_Done = TRUE;
	return;
    }
    wo->wo_LowPage = page;
    wo->wo_HighPage = entryNum;
    wo->wo_NextKey = nextKey;
    wo->wo_NeedsAttention = TRUE;
    break;
  case RF_DIRECTORY_OPEN:
  case RF_FILE_OPEN:
    if (status != RF_SUCCESS) {
	qprintf(("BARF error code %d on OPEN\n", status));
	wo->wo_Error = BARF_to_error[status];
	wo->wo_Done = TRUE;
	return;
    }
    childFile = (File *) CheckItem(fileIOReq->fio.io_Info.ioi_CmdOptions,
				     FILEFOLIO, FILENODE);
    if (!childFile) {
	wo->wo_Error = MakeFErr(ER_SEVER,ER_C_STND,ER_SoftErr);
	DBUG(("RF_*_OPEN reply, no file item!\n"));
    } else {
	childFile->fi_FilesystemSpecificData =
	  (uint32) reply->reply_Barf.br_Buffer[0];
	childFile->fi_Flags &= ~FILE_NOT_READY;
	DBUG(("RF_*_OPEN reply, handle is %d, file %s open for business\n",
	      childFile->fi_FilesystemSpecificData,
	      childFile->fi_FileName));
    }
    wo->wo_Done = TRUE;
    break;
  case RF_DIRECTORY_CLOSE:
  case RF_FILE_CLOSE:
    if (status != RF_SUCCESS) {
	qprintf(("BARF error code %d on CLOSE\n", status));
    } else {
	DBUG(("RF_*_CLOSE ok\n"));
    }
    wo->wo_Done = TRUE;
    break;
  default:
    qprintf(("Can't handle BARF response %d yet\n",
	       reply->reply_Barf.br_OperationType));
    break;
  }
}

/*
 * Update timeout predictors:
 * set timeout-related flags in request and update
 * timeout values according to from Appendix A of
 * "Congestion Avoidance and Control" by
 * Jacobson & Karels, Nov. 1988.
 *
 * Note:      	"scaledAvg" 		is "sa" in J&K
 *		"scaledVariance" 	is "sv" in J&K
 *		"observedDelay"		is "m"  in J&K
 */
static void
UpdateTimeOut(uchar barfOp, int32 observedDelay)
{
  register timeOutInfo_t *toi;

  ASSERT(barfOp < (sizeof timeOutInfo /sizeof timeOutInfo[0]));

  toi = &(timeOutInfo[barfOp]);

  observedDelay -= (toi->scaledAvg >> 3);
  toi->scaledAvg += observedDelay;
  if (observedDelay < 0)
    observedDelay = -observedDelay;
  observedDelay -= (toi->scaledVariance >> 2);
  toi->scaledVariance += observedDelay;
  toi->timeOut = (toi->scaledAvg >> 3) + toi->scaledVariance;
}

/*
 * Return the smallest range that spans all missing pages.
 * Return 0 if no missing pages, 1 otherwise.
 * In the pageBits array, if a bit is on it indicates a missing page.
 * Pages are numbered 0 .. 255.
 */
static int
MissingPageRange(
  uint32 *pageBits,		/* bits representing returned pages */
  uint32 *low,
  uint32 *high)
{
  int32 l = -1 , h = 0;
  uint32 i, j;
  register uint32 word;

# define CURRENT_BIT_NUM(word, bit)	(((word) * 32) + (bit))
# define HI_BIT				0x80000000

  for (i = 0; i < BARF_PAGE_BITS_SIZE; i++) {
    word = *pageBits++;
    if (!word) {
      /* optim: if word is 0, don't need to look at it */
      continue;
    }

    for (j = 0; j < 32; j++, word <<= 1) {
      if (word & HI_BIT) {
	h = CURRENT_BIT_NUM(i, j);
	if (l == -1)
	  l = h;
      }
    }
  }
  
  if (l == -1)		/* failure: didn't find any bits */
    return (0);

  *low = (uint32)l;
  *high = (uint32)h;
  return (1);
}

/*
 * Update the pageBits bit vector to reflect the
 * fact that we're retrying the range
 * missingPageLow .. missingPageHigh.
 * This amounts to shifting the bit vector left by
 * "missingPageLow".
 */
static void
UpdatePageBits(
  uint32 *pageBits,
  uint32 missingPageLow,
  uint32 missingPageHigh)
{
  uint32 tmpPageBits[BARF_PAGE_BITS_SIZE];
  uint32 i = missingPageLow;

  memset(tmpPageBits, 0, sizeof tmpPageBits);

  for (i = missingPageLow; i <= missingPageHigh; i++) {
    if (BIT_IS_SET(pageBits, i)) {
      SET_BIT(tmpPageBits, i - missingPageLow);
    }
  }

  memcpy(pageBits, tmpPageBits, sizeof tmpPageBits);
}

#ifdef DEBUG
void
PrintPageBits(pageBits)
  uint32 *pageBits;		/* bits representing returned pages */
{
  register int i;

  qprintf(("PageBits: "));

  for (i = 0; i < BARF_PAGE_BITS_SIZE; i++, pageBits++) {
    qprintf(("0x%x ",  *pageBits));
  }
  qprintf(("\n"));
}
#endif /* DEBUG */

/*
 * Retry a timed out command (in a clever manner, if possible):
 * it is likely that we have to retry the command because
 * a small percentage of the blocks we asked for in a multi-read
 * weren't delivered.  If so, it makes more sense to ask for the
 * blocks that didn't show up, rather than all the blocks in the
 * multiread.
 *
 * Return true if were able to smart-retry the cmd.
 */
static Err
SmartRetryServerRequest(theDevice, req)
  BarfDisk *theDevice;
  ServerRequest *req;
{
  Err err;
  static uint32 retryNum;

  /*
   * We're going to examine the command and depend
   * on the interrupt-level code (call-back code) not
   * fooling with the command data structures.
   */
  ASSERT((theDevice->bd_ServiceLock == BARFDISK_SERVICE_LOCKED) ||
	 (theDevice->bd_ServiceLock == BARFDISK_SERVICE_HIT));

  if (req->req_Barf.br_OperationType == RF_MULTI_READ) {
    /*
     * If it's a multiread, we can get clever:
     * rather than retry the entire request, we create
     * a new request ``in situ'' but ask only for the
     * page range that minimally covers the missing pages
     * (that is, the spanning set).
     */
    uint32 missingPageLow;
    uint32 missingPageHigh;
    uint32 blocks;

    /* determine "spanning set" of missing blocks */
    if (MissingPageRange(req->req_PageBits,
			 &missingPageLow, &missingPageHigh) == 0) {
      /*
       * Can't find any missing pages.  This is probably due to
       * replies coming in between the time the cmd timed out
       * and the time we looked for missing pages.
       * This should be indicated by bd_ServiceLock being set to
       * BARFDISK_SERVICE_HIT.
       */
      if (theDevice->bd_ServiceLock != BARFDISK_SERVICE_HIT) {
	qprintf(("SmartRetryServerRequest botch: can't find missing blk set\n"));
	return (0);
      } else {
	/*
	 * Kind of sleazy: we indicate that we've done a retry,
	 * but we haven't really; we count on the calling routine
	 * noticing that BARFDISK_SERVICE_HIT is set and re-examining
	 * the list of replies.
	 */
	return (1);
      }
    }
#ifdef STOP_AFTER_TIMEOUT
    stop_after_timeout_flag = 1; /* command timed out, stop sending cmds */
#endif

    blocks = missingPageHigh - missingPageLow + 1;
    
    /*
     * A few words about the PageBits array:
     *
     * This array represents the pages that we're missing.
     * In order to conserve retry commands, we issue a command
     * asking for the set of blocks which covers the missing blocks,
     * but we can ignore data returned for blocks in that range
     * that we've already received.  In fact, we *should* ignore
     * those blocks, to save the time unnecessarily copying
     * blocks from the server that we've alread received.
     *
     * However, because we are retrying the spanning set
     * of missing pages and this results in a new command
     * which starts at a higher block number than the original
     * request, we need to shift the PageBits array to match
     * this new request starting point.
     */
    
    UpdatePageBits(req->req_PageBits, missingPageLow, missingPageHigh);
    
    /*
     * missingPageLow, High are relative to start of request,
     * so add in starting block.
     */
    missingPageLow += req->req_LowPage;
    missingPageHigh += req->req_LowPage;
    
    /*
     * Modify the request to make it into a new request:
     * set page ranges, and mark the request as a smart retry.
     * 
     * Note that we inherit lots of information from the old request:
     * in particular, we don't need to change PagesPending and
     * the PageBits bitmask only needs to be shifted, as we are
     * still missing the same pages.
     */
    
    /* XXX cribbed from "while (wo->wo_NeedsAttention)" -- share code? */
    
    req->req_Barf.br_Buffer[1] = (uint8) (missingPageLow >> 16);
    req->req_Barf.br_Buffer[2] = (uint8) (missingPageLow >> 8);
    req->req_Barf.br_Buffer[3] = (uint8) missingPageLow;
    req->req_Barf.br_Buffer[4] = (uint8) blocks;
    
#ifdef DO_REQ_STATS
    req->req_Pages = blocks;
#endif
    
    req->req_LowPage = missingPageLow;
    
    if (!BARF_REQ_IS_SMART_RETRY(req)) {
      /*
       * First time we're retrying this request.
       */
      req->req_Flags |= BARF_REQ_SMART_FLAG;
    }

    /* DEBUG */
    qprintf(("doing smart retry #%d, req 0x%x seq no %d\n",
	     retryNum++, req, req->req_SequenceNumber));
    qprintf((" low page %d high page %d num missing %d\n",
	     missingPageLow, missingPageHigh, blocks));
  } else {
    /*
     * Retry command by setting the retry bit.
     */
    req->req_Barf.br_OperationType |= BARF_RETRY_MASK;

    /* DEBUG */
    qprintf(("doing dumb retry #%d, req 0x%x seq no %d\n",
	     retryNum++, req, req->req_SequenceNumber));
  }

  if (!BARF_REQ_IS_RETRY(req)) {
    /*
     * First time we're retrying this request.
     */
    req->req_Flags |= BARF_REQ_RETRY_FLAG;
    req->req_RetryBackOff = 2;
  } else {
    if (req->req_RetryBackOff < BARF_MAX_RETRY_BACK_OFF)
      /* double retry backoff */
      req->req_RetryBackOff <<= 1;
  }

  /*
   * Update timeout value,
   * taking back off into account.
   */
  if (req->req_MaxTime == 0) {
    /*
     * Not a multiread, or didn't receive a single block
     * for this request.  Since we don't have anything better,
     * use the last timeout recorded.
     */
    req->req_MaxTime = timeOutInfo[BARF_REQ_OP(req)].timeOut;
    qprintf(("seq %d, no blocks received, using %d as timeout\n",
	     req->req_SequenceNumber & 0x0000FFFF,
	     req->req_MaxTime));
  }

  qprintf(("seq %d, updating timeout to %d\n",
	   req->req_SequenceNumber & 0x0000FFFF,
	   req->req_MaxTime * req->req_RetryBackOff));

#ifndef STOP_AFTER_TIMEOUT
  UpdateTimeOut(BARF_REQ_OP(req), req->req_MaxTime * req->req_RetryBackOff);
#endif

  /* fire up the request */
  req->req_Phase = REQUEST_SENDING;
  req->req_TimeoutStart =
    fileFolio->ff_Daemon.ffd_TimerDevice->timerdev_VBlankCount;
  req->req_TimeoutLimit = BARF_WRITE_TIMEOUT;
  DBUG(("Sending server request seq %d\n", req->req_SequenceNumber));

  err = SuperinternalSendIO(req->req_IOReq);
  if (err < 0) {
    qprintf(("OOPS!  Server request-send got an error\n"));
    MySysErr(err);
    return (err);
  } else {
    DBUG(("Sent\n"));
  }

  return (1);
}


/*
 * "ScheduleIO" Barf fs driver entry point:
 * Schedule pending IO on the fs and handle IOs
 * in process.
 */
void
ScheduleBarfDiskIo(BarfDisk *theDevice)
{
  int32 interrupts;
  ServerReply *reply;
  ServerRequest *req, *nextReq;
  WorkOrder *wo, *nextWO;
  IOReq *ioReq;
  FileIOReq *fileIOReq;
  OpenFile *openFile;
  File *theFile;
  FileSystem *fs;
  uint32 page;
  int32 blocks;
  int32 i;
#ifdef DEBUG
  int32 didWork;
#endif
  fs = theDevice->bd_FileSystem;
 beginHere: ;
#ifdef DEBUG
  didWork = FALSE;
#endif
/*
   Tell the interrupt-level code that we're already in this routine,
   so that it does not attempt to do I/O cleanup behind our backs.
   We could simply stay disabled for the whole time that we grovel
   through the workorder list, but that could lead to substantial
   interrupt latency.  Instead, we set a lock;  the read endaction code
   will alter this lock if it's called, to tell us that we need to
   re-run the reply-processor code.
*/
  interrupts = Disable();
  theDevice->bd_ServiceLock = BARFDISK_SERVICE_LOCKED;

#ifdef SCAN_FOR_LOST_READERS
  i = 0;
  reply = (ServerReply *) FirstNode(&theDevice->bd_ServerRepliesToProcess);
  while (IsNode(&theDevice->bd_ServerRepliesToProcess, reply)) {
    i++;
    reply = (ServerReply *) NextNode(reply);
  }
  reply = (ServerReply *) FirstNode(&theDevice->bd_ServerRepliesReading);
  while (IsNode(&theDevice->bd_ServerRepliesReading, reply)) {
    i++;
    reply = (ServerReply *) NextNode(reply);
  }
#endif /* SCAN_FOR_LOST_READERS */

  Enable(interrupts);
  DBUG2(("BARF I/O scheduler!\n"));

#ifdef SCAN_FOR_LOST_READERS
  if (i != BARF_MIN_READERS) {
    DBUG0(("Expected %d readers, found only %d\n", BARF_MIN_READERS, i));
  }
#endif /* SCAN_FOR_LOST_READERS */

#ifdef NOTTRAFFIC
  if (busyTimer++ > 600) {
    busyTimer = 0;
    qprintf(("BARF no-traffic\n"));
    qprintf(("Replies-to-process is %s\n",
	     (IsEmptyList(&theDevice->bd_ServerRepliesToProcess)) ? "empty" : "not empty"));
    qprintf(("Replies-free is %s\n",
	     (IsEmptyList(&theDevice->bd_ServerRepliesFree)) ? "empty" : "not empty"));
    qprintf(("Replies-reading is %s\n",
	     (IsEmptyList(&theDevice->bd_ServerRepliesReading)) ? "empty" : "not empty"));
    qprintf(("Workorders-in-use is %s\n",
	     (IsEmptyList(&theDevice->bd_WorkOrdersInUse)) ? "empty" : "not empty"));
    qprintf(("Workorders-free is %s\n",
	     (IsEmptyList(&theDevice->bd_WorkOrdersFree)) ? "empty" : "not empty"));
  }
#endif /* NOTTRAFFIC */

  while (1) {
    interrupts = Disable();
    if (IsEmptyList(&theDevice->bd_ServerRepliesToProcess)) {
      Enable(interrupts);
      break;
    }
    reply = (ServerReply *) FirstNode(&theDevice->bd_ServerRepliesToProcess);
    RemNode((Node *) reply);
    Enable(interrupts);
    DBUG(("Got a reply to process!\n"));
#ifdef DEBUG
    didWork = TRUE;
#endif
    ioReq = reply->reply_IOReq;
    if (ioReq->io_Error < 0) {
      qprintf(("Network read error 0x%X", ioReq->io_Error));
#ifndef PRODUCTION
      MySysErr(ioReq->io_Error);
#endif
    } else {
      ProcessReply(reply, theDevice);
      StartReadOn(reply);
    }
  }

/*
   Loop through all workorders pending.  Do actual abort processing if
   necessary.  Do I/O completion if the ProcessReply() routine has flagged
   the workorder as being done.  Loop through all requests associated with
   this workorder and time 'em out if necessary.
*/
#ifdef DEBUG
  if (didWork) {
    DBUG(("Finished processing replies, checking workorders\n"));
  }
#endif
  DBUG2(("Checking workorders\n"));
  wo = (WorkOrder *) FirstNode(&theDevice->bd_WorkOrdersInUse);
  while (IsNode(&theDevice->bd_WorkOrdersInUse,wo)) {
    DBUG2(("Checking workorder 0x%X\n", wo));
    nextWO = (WorkOrder *) NextNode(wo);
    if (wo->wo_Aborted) {
      wo->wo_Error = MakeFErr(ER_SEVER,ER_C_STND,ER_Aborted);
      DBUG(("Abort workorder 0x%X\n", wo));
      WorkOrderDone(wo);
      wo = nextWO;
      continue;
    } else if (wo->wo_Done) {
      WorkOrderDone(wo);
      wo = nextWO;
      continue;
    }

    req = (ServerRequest *) FirstNode(&wo->wo_RequestsSubmitted);
    while (IsNode(&wo->wo_RequestsSubmitted, (Node *) req)) {
      DBUG2(("Checking request at 0x%X\n", req));
      nextReq = (ServerRequest *) NextNode(req);
      if ((req->req_Phase == REQUEST_SENDING && FSPARAM_SIMULATE_WRT_TIMEOUT)
	  || (req->req_TimeoutStart != 0 && req->req_TimeoutLimit != 0 &&
	  req->req_TimeoutStart + req->req_TimeoutLimit <
	    fileFolio->ff_Daemon.ffd_TimerDevice->timerdev_VBlankCount)) {

	/* Command timed out! */

	if (req->req_Phase == REQUEST_SENDING &&
	    !BARF_REQ_WAS_WRITTEN_OK(req)) {
	  /*
	   * If in sending phase and time out,
	   * set timeout limit to infinity.
	   */
	  if (FSPARAM_SIMULATE_WRT_TIMEOUT){
	    /* simulate a write timeout for debugging purposes */
	    fsParams[2] |= 0x1;
	    qprintf(("Faking a write timeout of seq # %d\n",
		     req->req_SequenceNumber & 0x0000FFFF));
	    req->req_TimeoutLimit = 0;
	  } else {
	    qprintf(("Request write seq %d has timed out! flg 0x%x phase %d Net jammed?\n",
		     req->req_SequenceNumber & 0x0000FFFF,
		     req->req_Flags, req->req_Phase));
	    if (BARF_REQ_WRITE_TIMED_OUT(req))
		    qprintf(("(and not for the first time!)\n"));
	    req->req_Flags |= BARF_REQ_WRITE_TIME_OUT_FLAG;
	    req->req_Flags &= ~BARF_REQ_WAS_SENT_FLAG;
	    /* req->req_TimeoutLimit = 0; */
	  }
	} else {
	  /*
	   * Command was written to the network folio,
	   * but never received a response.
	   */
	  qprintf(("Request 0x%X seq %d timed out, doing retry\n",
		   req, req->req_SequenceNumber & 0x0000FFFF));
	  if (SmartRetryServerRequest(theDevice, req) < 0) {
	    qprintf(("Request 0x%X seq %d retry failed!\n",
		     req, req->req_SequenceNumber & 0x0000FFFF));

	  }
	}
      }
      req = nextReq;
    } /* while (IsNode(&wo->wo_RequestsSubmitted, (Node *) req)) */

    while (wo->wo_NeedsAttention) {
      fileIOReq = wo->wo_FileIOReq;
      openFile = (OpenFile *) fileIOReq->fio.io_Dev;
      theFile = openFile->ofi_File;

      switch (fileIOReq->fio.io_Info.ioi_Command) {
      case CMD_READ:
	if (wo->wo_NumRequestsSubmitted >= MULTIREAD_WINDOW_SIZE) {
	  wo->wo_NeedsAttention = FALSE;
	  break;
	}
	page = wo->wo_FirstUnrequestedPage;
	blocks = wo->wo_HighPage - page + 1;
	if (blocks <= 0) {
	  wo->wo_NeedsAttention = FALSE;
	  DBUG(("Final was %d, first-unrequested %d, stop now\n",
		 wo->wo_HighPage, wo->wo_FirstUnrequestedPage));
	  break;
	} else if (blocks > MULTIREAD_BLOCK_LIMIT) {
	  blocks = MULTIREAD_BLOCK_LIMIT;
	}
	req = GetServerRequest(theDevice);
	if (!req) {
	  DBUG(("Needs-attention routine can't get server request\n"));
	  goto doNextWorkorder;
	}
	DBUG(("Scheduler multiread block %d count %d\n", page, blocks));
	wo->wo_FirstUnrequestedPage = page + blocks;
	req->req_Barf.br_OperationType = RF_MULTI_READ;
	req->req_Barf.br_Buffer[0] = (uint8) theFile->fi_FilesystemSpecificData;
	req->req_Barf.br_Buffer[1] = (uint8) (page >> 16);
	req->req_Barf.br_Buffer[2] = (uint8) (page >> 8);
	req->req_Barf.br_Buffer[3] = (uint8)  page;
	req->req_Barf.br_Buffer[4] = (uint8) blocks;
	req->req_PagesPending = blocks;
#ifdef DO_REQ_STATS
	req->req_Pages = blocks;
#endif
	req->req_LowPage = page;

	SetPageBits(req->req_PageBits, blocks);

        SubmitServerRequest(req, wo);
	if (wo->wo_FirstUnrequestedPage > wo->wo_HighPage) {
	  wo->wo_NeedsAttention = FALSE;
	  DBUG(("That was the final fetch request\n"));
	}
	break;

      case FILECMD_READDIR:
      case FILECMD_READENTRY:
	req = GetServerRequest(theDevice);
	if (!req) {
	  goto doNextWorkorder;
	}
	wo->wo_NeedsAttention = FALSE;
	req->req_Barf.br_OperationType = RF_DIRECTORY_READ;
	req->req_Barf.br_Buffer[0] = (uint8) theFile->fi_FilesystemSpecificData;
	memcpy(&req->req_Barf.br_Buffer[1], &wo->wo_NextKey, 4);
	DBUG(("Scheduler directory read key %d count %d\n", wo->wo_NextKey));
	SubmitServerRequest(req, wo);
	break;

      default:
	qprintf(("WHOOPS!  Workorder needs attention, I don't understand\n"));
	wo->wo_NeedsAttention = FALSE;
	break;
      }
    } /* while (wo->wo_NeedsAttention) */

  doNextWorkorder:  wo = nextWO;
  } /* while (IsNode(&theDevice->bd_WorkOrdersInUse,wo)) */

#ifdef DEBUG
  if (didWork) {
    DBUG(("Workorder check finished\n"));
  }
#endif
/*
   Check to see if we had to process one or more reply-messages at
   interrupt level due to reader starvation.  If so, fire up another
   reader to try to keep this from happening again.
*/
  if (theDevice->bd_NeedMoreReaders) {
    DBUG(("Need another service-reader!\n"));
#ifdef ADD_READERS
    reply = GetServerReply(theDevice);
    if (reply) {
      StartReadOn(reply);
    } else {
      DBUG0(("Failed to get another reader!\n"));
    }
#endif
    theDevice->bd_NeedMoreReaders = FALSE;
  }
/*
   Check to see if the read-endaction code got anything more for us to
   process.  If so, go process it.
*/
  interrupts = Disable();
  if (theDevice->bd_ServiceLock == BARFDISK_SERVICE_HIT) {
    Enable(interrupts);
    goto beginHere;
  } else {
    theDevice->bd_ServiceLock = BARFDISK_SERVICE_UNLOCKED;
    Enable(interrupts);
  }
  DBUG2(("All done.\n"));
}

/*
 * "StartIO" Barf fs driver entry point:
 * initiate IOs that are ready to go. 
 */
void
StartBarfDiskIo (BarfDisk *theDevice)
{
  FileIOReq *fileIOReq, *nextIOReq;
  ServerRequest *req;
  File *theFile, *childFile;
  int32 page, blocks, key, index, entryNum, offset, hit;
  int32 blocksRem;			/* blocks remaining in the file */
  WorkOrder *wo;
  int32 i;
  uchar *data;

  DBUG2(("Barf I/O initiator\n"));

  if ((theDevice->bd_FileSystem->fs_Flags & FILESYSTEM_NOT_READY) ||
      theDevice->bd_Trouble) {
    return;
  }

  /* may need to disable here, or rewrite, in order to handle abortio */

  DBUG2(("First I/O request is 0x%X\n", fileIOReq));
  fileIOReq = (FileIOReq *) FirstNode(&theDevice->bd.hdi_RequestsToDo);

  while (IsNode(&theDevice->bd.hdi_RequestsToDo, (Node *) fileIOReq)) {
    DBUG(("Processing I/O request 0x%X\n", fileIOReq));
    nextIOReq = (FileIOReq *) NextNode(fileIOReq);
    theFile = ((OpenFile *) fileIOReq->fio.io_Dev)->ofi_File;
    DBUG(("File structure is at 0x%X\n", theFile));

    if (theFile->fi_Flags & FILE_NOT_READY) {
      DBUG(("File not yet open for business\n"));
      fileIOReq = nextIOReq;
      continue;
    }

    DBUG(("Getting a work order\n"));
    wo = GetWorkOrder(theDevice);
    if (!wo) {
      qprintf(("Can't get BARF workorder\n"));
      goto initiatorDone;
    }

    DBUG(("Getting a request\n"));
    req = GetServerRequest(theDevice);
    if (!req) {
#if 0
      qprintf(("Initiator can't get BARF server-request\n"));
#endif
      ReleaseWorkOrder(wo, theDevice);
      goto initiatorDone;
    }

    RemNode((Node *) fileIOReq);
    AddTail(&theDevice->bd.hdi_RequestsRunning, (Node *) fileIOReq);
    wo->wo_FileIOReq = fileIOReq;

    switch (fileIOReq->fio.io_Info.ioi_Command) {
    case CMD_READ:
      DBUG(("Perform CMD_READ, %d bytes to 0x%X\n",
	    fileIOReq->fio.io_Info.ioi_Recv.iob_Len,
	    fileIOReq->fio.io_Info.ioi_Recv.iob_Buffer));
      page = wo->wo_LowPage = req->req_LowPage =
	fileIOReq->fio.io_Info.ioi_Offset;

      blocksRem = BYTES_TO_BLKNUM(theFile->fi_ByteCount, theFile) -
	fileIOReq->fio.io_Info.ioi_Offset + 1;

      if (blocksRem <= 0) {
	DBUG(("Read past EOF, bail!\n"));
	wo->wo_Error = MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_NoFile);
	ReleaseServerRequest(req, theDevice); /* won't need it */
	WorkOrderDone(wo);
	goto commandDone;
      }

      blocks = MIN(blocksRem,
	BYTES_TO_BLOCKS(fileIOReq->fio.io_Info.ioi_Recv.iob_Len, theFile));

      wo->wo_PageCount = blocks;
      wo->wo_HighPage = page + blocks - 1;
      req->req_Barf.br_Buffer[0] = (uint8) theFile->fi_FilesystemSpecificData;
      req->req_Barf.br_Buffer[1] = (uint8) (page >> 16);
      req->req_Barf.br_Buffer[2] = (uint8) (page >> 8);
      req->req_Barf.br_Buffer[3] = (uint8)  page;
      if (blocks == 1) {
	req->req_Barf.br_OperationType = RF_FILE_READ;
	wo->wo_FirstUnrequestedPage = page + 1;
	DBUG(("Initiator fileread block %d\n", page));
      } else {
	req->req_Barf.br_OperationType = RF_MULTI_READ;
	if (blocks > MULTIREAD_BLOCK_LIMIT) {
	  blocks = MULTIREAD_BLOCK_LIMIT;
	}
	DBUG(("Initiator multiread block %d count %d total %d\n", page,
	       blocks, wo->wo_PageCount));
	req->req_PagesPending = blocks;
#ifdef DO_REQ_STATS
	req->req_Pages = blocks;
#endif
	req->req_Barf.br_Buffer[4] = (uint8) blocks;
	wo->wo_FirstUnrequestedPage = page + blocks;
	SetPageBits(req->req_PageBits, blocks);
      }
      SubmitServerRequest(req, wo);
      if (wo->wo_FirstUnrequestedPage <= wo->wo_HighPage) {
	wo->wo_NeedsAttention = TRUE;
      }
      break;

    case FILECMD_READDIR:
      DBUG(("Perform FILECMD_READDIR\n"));

      /* 
       * Search the cache to see if we find it by index number.  
       * If not, fire off a read for the first block that we didn't
       * find in the cache.
       * TBD! - need to record the index of the first entry we expect
       * to see in that block, so we can count up from there.
       */

      page = key = 0; 
      index = 1;
      if (fsCacheBase) {
	/*
	 * Have a cache, search it.
	 */
	IoCacheEntry *entry;
	uint32 filesystemIdentifier, fileIdentifier;

	DBUG(("Searching cache\n"));
	fileIdentifier = theFile->fi_UniqueIdentifier;
	filesystemIdentifier = theFile->fi_FileSystem->fs_VolumeUniqueIdentifier;
	entry = (IoCacheEntry *) FirstNode(&fsCacheList);
	while (IsNode(&fsCacheList, entry)) {
	  if (entry->ioce_FilesystemUniqueIdentifier == filesystemIdentifier &&
	      entry->ioce_FileUniqueIdentifier == fileIdentifier &&
	      entry->ioce_CacheFirstIndex <= fileIOReq->fio.io_Info.ioi_Offset) {
	    data = (uchar *) entry->ioce_CachedBlock;
	    offset = 0;
	    entryNum = entry->ioce_CacheFirstIndex;
	    hit = FALSE;
	    while (offset < entry->ioce_CachedBlockSize && !hit) {
	      if (entryNum == fileIOReq->fio.io_Info.ioi_Offset) {
		hit = TRUE;
	      } else {
		entryNum ++;
		DBUG2(("Skip past %s\n", (char *) data+offset+5));
		offset += 6 + (int32) strlen((char *) data+offset+5);
	      }
	    }
	    if (hit) {
	      DBUG(("Cache hit!  Move to head of list\n"));
	      entry->ioce.n_Priority = CACHE_PRIO_HIT;
	      RemNode((Node *) entry);
	      AddHead(&fsCacheList, (Node *) entry);
	      BarfToDirectoryEntry(fileIOReq, data+offset);
	      ReleaseServerRequest(req, theDevice); /* won't need it */
	      WorkOrderDone(wo);
	      goto commandDone;
	    }
	    if (entry->ioce_FileBlockOffset >= page) {
	      page = entry->ioce_FileBlockOffset + 1; /* next page up */
	      key = entry->ioce_CacheMiscValue; /* next position key */
	      index = entryNum;
	    }
	  }
	  entry = (IoCacheEntry *) NextNode(entry);
	} /* (IsNode(&fsCacheList, entry)) */
      } /*if (fsCacheBase) */

      if (theFile->fi_BlockCount > 0 &&
	  theFile->fi_BlockCount <= page) {
	DBUG(("Not in cache, it's past end-of-directory, bail!\n"));
	wo->wo_Error = MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_NoFile);
	ReleaseServerRequest(req, theDevice); /* won't need it */
	WorkOrderDone(wo);
	goto commandDone;
      }

      req->req_Barf.br_OperationType = RF_DIRECTORY_READ;
      req->req_Barf.br_Buffer[0] = (uint8) theFile->fi_FilesystemSpecificData;
      memcpy(&req->req_Barf.br_Buffer[1], &key, 4);

      DBUG(("Not in cache, RF_DIRECTORY_READ for handle 0x%X key %d page %d\n",
	    req->req_Barf.br_Buffer[0], key, page));
      wo->wo_LowPage = page;
      wo->wo_HighPage = index;
      SubmitServerRequest(req, wo);
      break;

    case FILECMD_READENTRY:
      page = key = 0;
      index = 1;
      if (fsCacheBase) {
	/*
	 * Have a cache, search it by name.  If we don't find it,
	 * fire off a read for the first block we didn't see.
	 */
	IoCacheEntry *entry;
	int32 startKey;
	uint32 filesystemIdentifier, fileIdentifier;
	char fileName[32];

	memset(fileName, 0, sizeof fileName);
	i = (int32) fileIOReq->fio.io_Info.ioi_Send.iob_Len;
	if (i > 31) i = 31;
	memcpy(fileName, fileIOReq->fio.io_Info.ioi_Send.iob_Buffer, i);
	fileIdentifier = theFile->fi_UniqueIdentifier;
	filesystemIdentifier = theFile->fi_FileSystem->fs_VolumeUniqueIdentifier;
	entry = (IoCacheEntry *) FirstNode(&fsCacheList);
	startKey = 0;

	while (IsNode(&fsCacheList, entry)) {
	  if (entry->ioce_FilesystemUniqueIdentifier == filesystemIdentifier &&
	      entry->ioce_FileUniqueIdentifier == fileIdentifier) {
	    if (entry->ioce_FileBlockOffset == page) {
	      page ++;                          /* next page up */
	      key = entry->ioce_CacheMiscValue; /* next page key */
	    }
	    data = (uchar *) entry->ioce_CachedBlock;
	    offset = 0;
	    entryNum = entry->ioce_CacheFirstIndex;
	    hit = FALSE;

	    while (offset < entry->ioce_CachedBlockSize && !hit) {
	      if (strcasecmp(fileName, (char *) data+offset+5) == 0) {
		hit = TRUE;
	      } else {
		DBUG2(("Skip past %s\n", (char *) data+offset+5));
		offset += 6 + (int32) strlen((char *) data+offset+5);
	      }
	    }

	    if (hit) {
	      DBUG(("Cache hit!  Move to head of list\n"));
	      entry->ioce.n_Priority = CACHE_PRIO_HIT;
	      RemNode((Node *) entry);
	      AddHead(&fsCacheList, (Node *) entry);
	      BarfToDirectoryEntry(fileIOReq, data+offset);
	      ReleaseServerRequest(req, theDevice); /* won't need it */
	      WorkOrderDone(wo);
	      goto commandDone;
	    }
	    if (entry->ioce_FileBlockOffset == page) {
	      page++;
	      startKey = entry->ioce_CacheMiscValue;
	      index = entryNum;
	    }
	  }
	  entry = (IoCacheEntry *) NextNode(entry);
	} /* while (IsNode(&fsCacheList, entry)) */
	key = startKey;
      }

      if (theFile->fi_BlockCount > 0 &&
	  theFile->fi_BlockCount <= page) {
	DBUG(("Not in cache, it's past end-of-directory, bail!\n"));
	wo->wo_Error = MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_NoFile);
	ReleaseServerRequest(req, theDevice); /* won't need it */
	WorkOrderDone(wo);
	goto commandDone;
      }

      req->req_Barf.br_OperationType = RF_DIRECTORY_READ;
      req->req_Barf.br_Buffer[0] = (uint8) theFile->fi_FilesystemSpecificData;
      memcpy(&req->req_Barf.br_Buffer[1], &key, 4);
      DBUG(("Not in cache, RF_DIRECTORY_READ for handle 0x%X key %d page %d\n",
	    req->req_Barf.br_Buffer[0], key, page));
      wo->wo_LowPage = page;
      wo->wo_HighPage = index;
      SubmitServerRequest(req, wo);
      break;

    case FILECMD_OPENENTRY:
#ifdef NOTDEF
      if (!fileIOReq->fio.io_CallBack) {
	DBUG(("No callback, reject request\n"));
	wo->wo_Error = MakeFErr(ER_SEVER,ER_C_STND,ER_BadCommand);
	WorkOrderDone(wo);
	break;
      }
#endif
      childFile = (File *) CheckItem(fileIOReq->fio.io_Info.ioi_CmdOptions,
				     FILEFOLIO, FILENODE);
      if (!childFile) {
	wo->wo_Error = MakeFErr(ER_SEVER,ER_C_STND,ER_BadIOArg);
	WorkOrderDone(wo);
	break;
      }
      DBUG(("Do FILECMD_OPENENTRY on %s\n", childFile->fi_FileName));
      if (childFile->fi_Flags & FILE_IS_DIRECTORY) {
	req->req_Barf.br_OperationType = RF_DIRECTORY_OPEN;
      } else {
	req->req_Barf.br_OperationType = RF_FILE_OPEN;
      }
      childFile->fi_Flags |= FILE_NOT_READY;
      req->req_Barf.br_Buffer[0] = (uint8) theFile->fi_FilesystemSpecificData;
      req->req_Barf.br_Buffer[1] = (uint8) strlen(childFile->fi_FileName);
      memcpy(&req->req_Barf.br_Buffer[2], childFile->fi_FileName,
	     sizeof childFile->fi_FileName);
      SubmitServerRequest(req, wo);
      break;

    default:
      /*
       * unknown cmd type: this is an internal
       * logic error.
       */
      qprintf(("StartBarfDiskIO: unknown cmd %d\n",
	       fileIOReq->fio.io_Info.ioi_Command));
      wo->wo_Error = MakeFErr(ER_SEVER,ER_C_STND,ER_BadCommand);
      ReleaseServerRequest(req, theDevice); /* won't need it */
      WorkOrderDone(wo);
      goto commandDone;
	 
      break;
    }

  commandDone: ;
    fileIOReq = nextIOReq;
  } /* while (IsNode(&theDevice->bd.hdi_RequestsToDo, (Node *) fileIOReq)) */

 initiatorDone:
  if (theDevice->bd_NeedToRelease != 0 &&
      !IsEmptyList(&theDevice->bd_WorkOrdersFree) &&
      !IsEmptyList(&theDevice->bd_ServerRequestsFree)) {
    /*
     * We need to close a file and we have the resources
     * necessary to do it.
     */

    DBUG(("Initiating release of an old handle\n"));
    wo = GetWorkOrder(theDevice);
    if (!wo) {
      qprintf(("Can't get BARF workorder\n"));
      goto allDone;
    }

    DBUG(("Getting a request\n"));
    req = GetServerRequest(theDevice);
    if (!req) {
      qprintf(("Handle-release can't get BARF server-request\n"));
      ReleaseWorkOrder(wo, theDevice);
      goto allDone;
    }

    req->req_Barf.br_OperationType = RF_FILE_CLOSE;
    i = FirstIDSet(theDevice->bd_ReleaseFileIDs, 8);
    if (i < 0) {
      req->req_Barf.br_OperationType = RF_DIRECTORY_CLOSE;
      i = FirstIDSet(theDevice->bd_ReleaseDirectoryIDs, 8);
      if (i < 0) {
	theDevice->bd_NeedToRelease = 0;
	ReleaseServerRequest(req, theDevice);
	ReleaseWorkOrder(wo, theDevice);
	goto allDone;
      }
      DBUG(("Releasing directory handle %d\n", i));
    } else {
      DBUG(("Releasing file handle %d\n", i));
    }

    req->req_Barf.br_Buffer[0] = (uint8) i;
    SubmitServerRequest(req, wo);
    theDevice->bd_NeedToRelease --;
  }
 allDone:
  DBUG2(("BARF initiator done\n"));
}

/*
 * Call-back routine to be called on completion of a read
 * (that is, after receipt of a reply from the server).
 */
struct IOReq *
BarfReadCallback(struct IOReq *iorP)
{
  ServerReply *reply;
  BarfDisk *theDisk;
#ifdef MULTIJAB
  static int32 last_seqno;		/* last sequence number we saw */
  static uint32 num_rem_for_seqno;	/* num replies remaining for request */
  static uint32 seqno_jab_count;	/* num replies rcvd before last jab */
#endif

  reply = (ServerReply *) iorP->io_Info.ioi_User;
  theDisk = reply->reply_Disk;
  RemNode((Node *) reply);

#ifdef TRACE_REPLIES
  {
    uchar *b = &(reply_trace_buf[rtbi]);

    *b++ = reply->reply_Barf.br_SeqLSB;
    *b++ = reply->reply_Barf.br_Buffer[1];
    *b++ = reply->reply_Barf.br_Buffer[2];
    *b++ = reply->reply_Barf.br_Buffer[3];

    rtbi += 4;
    if (rtbi >= 16 * 512)
      rtbi = 0;
  }
#endif

#ifdef ENDACTION_PROCESS
/*
   If this was the last read camped on the net connection, then
   we should process it immediately and reissue the read so that we
   don't leave the socket high & dry without a read.  This situation
   should only occur rarely, if a burst of data arrives rapidly and
   the system is so bogged down that it hasn't been able to wake up
   the daemon to run the I/O scheduler for this device.  It's unfortunate
   when it does occur, as it means that a significant amount of processing
   must be done here in I/O endaction (with interrupts inhibited) rather
   than in the scheduler thread.  Make a note that it has occurred, so that
   the scheduler can opt to add an additional reader.
*/
  if (theDisk->bd_ServiceLock != BARFDISK_SERVICE_LOCKED &&
      IsEmptyList(&theDisk->bd_ServerRepliesReading)) {
    theDisk->bd_NeedMoreReaders = TRUE;
    ProcessReply(reply, theDisk);
    AddTail(&theDisk->bd_ServerRepliesReading, (Node *) reply);
    return iorP;
  }
#endif
/*
   OK, this isn't the last reader... queue the reply for processing
   and awaken the daemon.
*/
  theDisk->bd_ServiceLock = BARFDISK_SERVICE_HIT;
  AddTail(&theDisk->bd_ServerRepliesToProcess, (Node *) reply);









#ifdef MULTIJAB
  /*
   * If it's a multiread reply & we think that we're going
   * to be getting more replies soon, don't signal the file daemon to
   * schedule IO every time; the context switch burns CPU cycles
   * unnecessarily.  Instead, wait until we've accumulated a number
   * of replies and then signal.
   *
   * Note: the way this is currently implemented is a crock:
   * having replies come back for more than one pending multiread
   * will cause the code to jab the scheduler whenever a reply
   * w/a different sequence number comes back from the server.
   * We probably want to save information on a per-multiread basis,
   * one for each currently outstanding multiread, and signal upon
   * completion of each multiread.
   */
  if (BARF_REPL_OP(reply) == RF_MULTI_READ) {
	int32 seqno;
	  
	seqno = (((uint32) reply->reply_Barf.br_SeqMSB) << 8) +
	  reply->reply_Barf.br_SeqLSB;

	MULTIJAB_BLAB(("multijab: seqno %d\n", seqno));

	if (seqno != last_seqno) {
	  /* haven't seen this one yet */
	  uint32 mask;
	  ServerRequest *req;

	  /* track num remaining for this req */

	  mask = theDisk->bd_SequenceTableSize - 1;
	  req = theDisk->bd_ServerRequestsOutstanding[seqno & mask];
	  num_rem_for_seqno = req->req_PagesPending;

	  MULTIJAB_BLAB(("multijab: new seqno (old %d), num rem %d\n",
			   last_seqno, num_rem_for_seqno));
	  last_seqno = seqno;
	}

	if ((num_rem_for_seqno-- > 1 && seqno_jab_count++ < 16)) {
	  MULTIJAB_BLAB(("multijab: not jabbing num rem %d jab %d\n",
			 num_rem_for_seqno, seqno_jab_count));
	  return (IOReq *) NULL;
	} else {
	  MULTIJAB_BLAB(("multijab: jabbing\n"));
	  seqno_jab_count = 0;
	  goto jab_and_exit;
	}
  }

 jab_and_exit:
#endif /* MULTIJAB */
  SuperinternalSignal(fileFolio->ff_Daemon.ffd_Task,
						fileFolio->ff_Daemon.ffd_RescheduleSignal);
  return (IOReq *) NULL;
}

/*
 * Call-back routine to be called on completion of a write
 * (that is, after sending request to the server).
 * Used to start a time-out for the request.
 */
struct IOReq *
BarfWriteCallback(struct IOReq *iorP)
{
  ServerRequest *req;
  int32 interrupts;

  if (iorP->io_Error < 0) {
    qprintf(("Write error "));
    MySysErr(iorP->io_Error);
  } else {
    interrupts = Disable();
    req = (ServerRequest *) iorP->io_Info.ioi_User;
    req->req_Flags |= BARF_REQ_WRITTEN_OK;
    req->req_TimeoutStart =
      fileFolio->ff_Daemon.ffd_TimerDevice->timerdev_VBlankCount;

    req->req_TimeoutLimit = timeOutInfo[BARF_REQ_OP(req)].timeOut +
      ADAPTIVE_FIXED_TIMEOUT;
    
    if (req->req_Phase == REQUEST_SENDING) {
      req->req_Phase = REQUEST_SENT;
    }
    Enable(interrupts);
    DBUG(("Write done!\n"));
#if 0
    /* debug */
    qprintf(("write seq %d got callback\n",
	     req->req_SequenceNumber & 0x0000FFFF));
#endif
    if (BARF_REQ_WRITE_TIMED_OUT(req))
	    qprintf(("timed out write seq %d completed\n",
		     req->req_SequenceNumber & 0x0000FFFF));
  }
  return NULL;
}

/*
 * "CloseFile" Barf fs driver entry point:
 * close the file by marking its  handle as
 * "needing to be released".
 */
static void
BarfDiskCloseFile(File *theFile)
{
  int32 word, mask, handle;
  BarfDisk *theDisk;

  if (!(theFile->fi_Flags & FILE_NOT_READY)) {
    handle = theFile->fi_FilesystemSpecificData;
    if (handle < 0) {
      DBUG0(("OOPS, duplicate release for %s\n", handle));
      return;
    }
    theFile->fi_FilesystemSpecificData = -1;

    DBUG(("Need to release %s handle %d for %s\n",
	     (theFile->fi_Flags & FILE_IS_DIRECTORY) ? "directory" : "file",
	     handle, theFile->fi_FileName));

    theDisk = (BarfDisk *) theFile->fi_FileSystem->fs_Device;
    word = handle / 32;
    mask = ((uint32) 0x80000000) >> (handle % 32);

    DBUG(("Set word %d mask 0x%08X\n", word, mask));

    if (theFile->fi_Flags & FILE_IS_DIRECTORY) {
      if (theDisk->bd_ReleaseDirectoryIDs[word] & mask) {
	DBUG0(("WHOOPS!  That release bit is already set!\n"));
      }
      theDisk->bd_ReleaseDirectoryIDs[word] |= mask;
    } else {
      if (theDisk->bd_ReleaseFileIDs[word] & mask) {
	DBUG0(("WHOOPS!  That release bit is already set!\n"));
      }
      theDisk->bd_ReleaseFileIDs[word] |= mask;
    }
    theDisk->bd_NeedToRelease ++;
  }    
}


/*
 * Routine to mount a Barf fs.
 */
Item
MountBarfFilesystem(Device *theDevice, int32 unit, uint32 blockOffset)
{
  FileSystem *fileSystem = NULL;
  BarfDisk *fsDevice = NULL;
  Item fsDeviceItem, filesystemItem, rootFileItem;
  File *fsRoot = NULL;
  int32 fileSize;
  TagArg fsDeviceArgBlock[4];
  Err err;
  List tempList;
  WorkOrder *wo;
  ServerRequest *req;
  ServerReply *reply;
  int32 i;

  wo = NULL;
  req = NULL;
  reply = NULL;
  err = MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_NoFileSystem);

  DBUG(("Creating BARF device\n"));

  memcpy(fsDeviceArgBlock, fsDevArgs, sizeof fsDeviceArgBlock);
  fsDeviceArgBlock[1].ta_Arg = (void *) fileDriver->drv.n_Item;
  fsDeviceItem = SuperCreateSizedItem(MKNODEID(KERNELNODE,DEVICENODE),
 				      fsDeviceArgBlock,
 				      sizeof (BarfDisk));
  fsDevice = (BarfDisk *) LookupItem(fsDeviceItem);
  if (!fsDevice) {
    qprintf(("Could not allocate BARF disk device\n"));
    err = fsDeviceItem;
    goto nuke;
  }

  DBUG(("BARF device created, initializing structure\n"));

  fsDevice->bd.hdi_DeviceType = FILE_DEVICE_BARF_DISK;
  fsDevice->bd.hdi_QueueRequest = (FileDriverQueueit) QueueBarfDiskRequest;
  fsDevice->bd.hdi_ScheduleIO = (FileDriverHook) ScheduleBarfDiskIo;
  fsDevice->bd.hdi_StartIO = (FileDriverHook) StartBarfDiskIo;
  fsDevice->bd.hdi_AbortIO = (FileDriverAbort) AbortBarfDiskIo;
  fsDevice->bd.hdi_EndAction = NULL;
  fsDevice->bd.hdi_CloseFile = (FileDriverClose) BarfDiskCloseFile;
  fsDevice->bd_NetDevice = theDevice;
  fsDevice->bd_NetUnit = (uint8) unit;
  fsDevice->bd_SequenceTableSize = BARF_WINDOW_SIZE;
  fsDevice->bd_ServerWindowSize = BARF_WINDOW_SIZE;
  fsDevice->bd_Trouble = FALSE;
  fsDevice->bd_ServiceLock = BARFDISK_SERVICE_UNLOCKED;
  fsDevice->bd_Flags = 0;

  DBUG(("Initializing lists\n"));

  InitList(&fsDevice->bd.hdi_RequestsToDo, "To do");
  InitList(&fsDevice->bd.hdi_RequestsRunning, "Running");
  InitList(&fsDevice->bd.hdi_RequestsDeferred, "Deferred");
  InitList(&fsDevice->bd_WorkOrdersInUse, NULL);
  InitList(&fsDevice->bd_WorkOrdersFree, NULL);
  InitList(&fsDevice->bd_ServerRequestsFree, NULL);
  InitList(&fsDevice->bd_ServerRepliesFree, NULL);
  InitList(&fsDevice->bd_ServerRepliesReading, NULL);
  InitList(&fsDevice->bd_ServerRepliesToProcess, NULL);
  InitList(&tempList, NULL);

  /*
   * Create a filesystem which resides on the device 
   */
  DBUG(("Creating filesystem node\n"));

  filesystemItem = SuperCreateItem(MKNODEID(FILEFOLIO,FILESYSTEMNODE),
 				   (TagArg *) filesystemArgs);
  fileSystem = (FileSystem *) LookupItem(filesystemItem);
  if (!fileSystem) {
    qprintf(("Could not create filesystem\n"));
    err = filesystemItem;
    goto nuke;
  }
  fileSystem->fs_Device = (HighLevelDisk *) fsDevice;
  fileSystem->fs_Flags = (FILESYSTEM_IS_READONLY |
 			  FILESYSTEM_IS_IMPORTED |
			  FILESYSTEM_NEEDS_VBLS  |
			  FILESYSTEM_NOT_READY);

  DBUG(("Creating root-descriptor file node\n"));

  fileSize = (int32) (sizeof(File));
  rootFileItem = SuperCreateSizedItem(MKNODEID(FILEFOLIO,FILENODE),
 				      (void *) NULL, fileSize);
  fsRoot = (File *) LookupItem(rootFileItem);
  if (!fsRoot) {
    qprintf(("Could not create root file node\n"));
    err = rootFileItem;
    goto nuke;
  }
  AddHead(&fileFolio->ff_Files, (Node *) fsRoot);

  DBUG(("Initializing root directory\n"));

  fsRoot->fi_FileSystem = fileSystem;
  fsRoot->fi_Type = FILE_TYPE_DIRECTORY;
  fsRoot->fi_ParentDirectory = fileFolio->ff_Root;
  fileFolio->ff_Root->fi_UseCount ++;
  fsRoot->fi_Flags = (FILE_IS_DIRECTORY |
		      FILE_IS_READONLY |
		      FILE_IS_FOR_FILESYSTEM |
		      FILE_SUPPORTS_DIRSCAN |
		      FILE_SUPPORTS_ENTRY);
  fsRoot->fi_UseCount = 1; /* lock it in */
  fsRoot->fi_Burst = 1;
  fsRoot->fi_Gap = 0;
  fsRoot->fi_BlockSize = FILESYSTEM_DEFAULT_BLOCKSIZE; /* this will change */
  fsRoot->fi_BlockCount = 0;
  fsRoot->fi_ByteCount = 0;
  fsRoot->fi_UniqueIdentifier = fileFolio->ff_NextUniqueID --;
  fsRoot->fi_LastAvatarIndex = -1;
  fsRoot->fi_FilesystemSpecificData = RF_ROOT_HANDLE;
#ifdef FS_DIRSEMA
  InitDirSema(fsRoot, 1);
#endif  
  strcpy((char *) fsRoot->fi_FileName, "BARF"); /* this needs to improve... */
  strcpy((char *) fileSystem->fs_FileSystemName, "BARF"); /* likewise */
  fileSystem->fs_VolumeBlockSize = FILESYSTEM_DEFAULT_BLOCKSIZE;
  fileSystem->fs_VolumeBlockCount = -1;
  fileSystem->fs_VolumeUniqueIdentifier = fileFolio->ff_NextUniqueID --;
  fileSystem->fs_DeviceBlocksPerFilesystemBlock = 1;
  fileSystem->fs_RootDirectory = fsRoot;
  fsDevice->bd_FileSystem = fileSystem;
  reply = GetServerReply(fsDevice);
  if (!reply) {
    qprintf(("Can't get initial server-reply-listener!\n"));
    goto nuke;
  }

  DBUG(("Starting first network read\n"));

  StartReadOn(reply);

  DBUG(("Starting additional readers\n"));

  for (i = 2; i <= BARF_MIN_READERS; i++) {
    reply = GetServerReply(fsDevice);
    if (reply) {
      StartReadOn(reply);
    }
  }

  /*
   * Allocate some WorkOrders and add them
   * to the free list.
   */
  for (i = 1; i <= BARF_MIN_REQUESTORS; i++) {
    wo = GetWorkOrder(fsDevice);
    if (!wo) {
      qprintf(("Can't get BARF workorder\n"));
      goto nuke;
    }
  }

  while (!IsEmptyList(&fsDevice->bd_WorkOrdersInUse)) {
    wo = (WorkOrder *) FirstNode(&fsDevice->bd_WorkOrdersInUse);
    RemNode((Node *) wo);
    AddTail(&fsDevice->bd_WorkOrdersFree, (Node *) wo);
    DBUG2(("Moved workorder at 0x%X to free list\n", wo));
  }  

  /*
   * Allocate some ServerRequests and add them
   * to the free list.
   */
  for (i = 1; i <= BARF_MIN_REQUESTORS; i++) {
    req = GetServerRequest(fsDevice);
    if (!req) {
      qprintf(("Can't get BARF server-request\n"));
      goto nuke;
    }
    AddTail(&tempList, (Node *) req);
  }

  while (!IsEmptyList(&tempList)) {
    req = (ServerRequest *) LastNode(&tempList);
    RemNode((Node *) req);
    ReleaseServerRequest(req, fsDevice);
  }

  fsDevice->bd_NextSequenceNumber = 0;
  wo = GetWorkOrder(fsDevice);
  if (!wo) {
    qprintf(("Can't get BARF workorder\n"));
    goto nuke;
  }
  req = GetServerRequest(fsDevice);
  if (!req) {
    qprintf(("Can't get BARF server-request\n"));
    goto nuke;
  }
  req->req_WorkOrder = wo;
  req->req_Barf.br_OperationType = RF_START;

  DBUG(("Sending RF_START request\n"));

  SubmitServerRequest(req, wo);

  qprintf(("BARF version %s\n", BARF_VERSION_STRING));
  qprintf(("Filesystem /%s starting up\n", fileSystem->fs_FileSystemName));
  AddTail(&fileFolio->ff_Filesystems, (Node *) fileSystem);
  GiveDaemon(fsRoot);
  GiveDaemon(fileSystem);
  GiveDaemon(fsDevice);
  GiveDaemon(theDevice); /* this is draconion but probably a good idea */
  SuperinternalSignal(fileFolio->ff_Daemon.ffd_Task,
		      fileFolio->ff_Daemon.ffd_RescheduleSignal);
  return filesystemItem;

  /* 
   * Nuke may leak memory - gotta make sure that deleting a
   * BarfDisk cleans up the lists.
   */

 nuke:
  if (wo) {
    ReleaseWorkOrder(wo, fsDevice);
  }
  if (reply) {
    FreeMem(reply, sizeof (ServerReply));
  }
  Nuke(fsRoot);
  Nuke(fileSystem);
  Nuke(fsDevice);
  return MakeFErr(ER_SEVER,ER_C_NSTND,ER_Fs_NoFileSystem);
}

#else /* BARFFS */

/*
 * If BARFFS isn't defined, the compiler will complain
 * if it has nothing to compile!
 */
static int foo;

#endif /* BARFFS */
